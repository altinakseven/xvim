//! Syntax highlighting module
//!
//! This module provides syntax highlighting functionality for the editor.

use crate::buffer::Buffer;
use std::io::Read;
use std::fs::File;
use std::io::Read;
use std::path::PathBuf;
use std::io::Read;
use std::fs::File;
use std::io::Read;
use std::path::Path;
use std::io::Read;
use std::fs::File;
use std::io::Read;
use std::path::PathBuf;
use std::io::Read;
use std::fs::File;
use std::io::Read;
use std::sync::Mutex;
use std::io::Read;
use std::fs::File;
use std::io::Read;
use std::path::PathBuf;
use std::io::Read;
use std::fs::File;
use std::io::Read;
use std::path::Path;
use std::io::Read;
use std::fs::File;
use std::io::Read;
use std::path::PathBuf;
use std::io::Read;
use std::fs::File;
use std::io::Read;
use std::sync::Arc;
use std::io::Read;
use std::fs::File;
use std::io::Read;
use std::path::PathBuf;
use std::io::Read;
use std::fs::File;
use std::io::Read;
use std::path::Path;
use std::io::Read;
use std::fs::File;
use std::io::Read;
use std::path::PathBuf;
use std::io::Read;
use std::fs::File;
use std::io::Read;
use std::sync::Mutex;
use std::io::Read;
use std::fs::File;
use std::io::Read;
use std::path::PathBuf;
use std::io::Read;
use std::fs::File;
use std::io::Read;
use std::path::Path;
use std::io::Read;
use std::fs::File;
use std::io::Read;
use std::path::PathBuf;
use std::io::Read;
use std::fs::File;
use std::io::Read;
use std::collections::HashMap;
use std::io::Read;
use std::fs::File;
use std::io::Read;
use std::path::PathBuf;
use std::io::Read;
use std::fs::File;
use std::io::Read;
use std::path::Path;
use std::io::Read;
use std::fs::File;
use std::io::Read;
use std::path::PathBuf;
use std::io::Read;
use std::fs::File;
use std::io::Read;
use std::sync::Mutex;
use std::io::Read;
use std::fs::File;
use std::io::Read;
use std::path::PathBuf;
use std::io::Read;
use std::fs::File;
use std::io::Read;
use std::path::Path;
use std::io::Read;
use std::fs::File;
use std::io::Read;
use std::path::PathBuf;
use std::io::Read;
use std::fs::File;
use std::io::Read;
use std::sync::Arc;
use std::io::Read;
use std::fs::File;
use std::io::Read;
use std::path::PathBuf;
use std::io::Read;
use std::fs::File;
use std::io::Read;
use std::path::Path;
use std::io::Read;
use std::fs::File;
use std::io::Read;
use std::path::PathBuf;
use std::io::Read;
use std::fs::File;
use std::io::Read;
use std::sync::Mutex;
use std::io::Read;
use std::fs::File;
use std::io::Read;
use std::path::PathBuf;
use std::io::Read;
use std::fs::File;
use std::io::Read;
use std::path::Path;
use std::io::Read;
use std::fs::File;
use std::io::Read;
use std::path::PathBuf;
use std::io::Read;
use std::fs::File;
use std::io::Read;
use std::collections::{HashMap, HashSet};
use std::io::Read;
use std::fs::File;
use std::io::Read;
use std::path::PathBuf;
use std::io::Read;
use std::fs::File;
use std::io::Read;
use std::path::Path;
use std::io::Read;
use std::fs::File;
use std::io::Read;
use std::path::PathBuf;
use std::io::Read;
use std::fs::File;
use std::io::Read;
use std::sync::Mutex;
use std::io::Read;
use std::fs::File;
use std::io::Read;
use std::path::PathBuf;
use std::io::Read;
use std::fs::File;
use std::io::Read;
use std::path::Path;
use std::io::Read;
use std::fs::File;
use std::io::Read;
use std::path::PathBuf;
use std::io::Read;
use std::fs::File;
use std::io::Read;
use std::sync::Arc;
use std::io::Read;
use std::fs::File;
use std::io::Read;
use std::path::PathBuf;
use std::io::Read;
use std::fs::File;
use std::io::Read;
use std::path::Path;
use std::io::Read;
use std::fs::File;
use std::io::Read;
use std::path::PathBuf;
use std::io::Read;
use std::fs::File;
use std::io::Read;
use std::sync::Mutex;
use std::io::Read;
use std::fs::File;
use std::io::Read;
use std::path::PathBuf;
use std::io::Read;
use std::fs::File;
use std::io::Read;
use std::path::Path;
use std::io::Read;
use std::fs::File;
use std::io::Read;
use std::path::PathBuf;
use std::io::Read;
use std::fs::File;
use std::io::Read;
use std::collections::HashMap;
use std::io::Read;
use std::fs::File;
use std::io::Read;
use std::path::PathBuf;
use std::io::Read;
use std::fs::File;
use std::io::Read;
use std::path::Path;
use std::io::Read;
use std::fs::File;
use std::io::Read;
use std::path::PathBuf;
use std::io::Read;
use std::fs::File;
use std::io::Read;
use std::sync::Mutex;
use std::io::Read;
use std::fs::File;
use std::io::Read;
use std::path::PathBuf;
use std::io::Read;
use std::fs::File;
use std::io::Read;
use std::path::Path;
use std::io::Read;
use std::fs::File;
use std::io::Read;
use std::path::PathBuf;
use std::io::Read;
use std::fs::File;
use std::io::Read;
use std::sync::Arc;
use std::io::Read;
use std::fs::File;
use std::io::Read;
use std::path::PathBuf;
use std::io::Read;
use std::fs::File;
use std::io::Read;
use std::path::Path;
use std::io::Read;
use std::fs::File;
use std::io::Read;
use std::path::PathBuf;
use std::io::Read;
use std::fs::File;
use std::io::Read;
use std::sync::Mutex;
use std::io::Read;
use std::fs::File;
use std::io::Read;
use std::path::PathBuf;
use std::io::Read;
use std::fs::File;
use std::io::Read;
use std::path::Path;
use std::io::Read;
use std::fs::File;
use std::io::Read;
use std::path::PathBuf;
use std::io::Read;
use std::fs::File;
use std::io::Read;
use std::fs::{self, File};
use std::io::Read;
use std::fs::File;
use std::io::Read;
use std::path::PathBuf;
use std::io::Read;
use std::fs::File;
use std::io::Read;
use std::path::Path;
use std::io::Read;
use std::fs::File;
use std::io::Read;
use std::path::PathBuf;
use std::io::Read;
use std::fs::File;
use std::io::Read;
use std::sync::Mutex;
use std::io::Read;
use std::fs::File;
use std::io::Read;
use std::path::PathBuf;
use std::io::Read;
use std::fs::File;
use std::io::Read;
use std::path::Path;
use std::io::Read;
use std::fs::File;
use std::io::Read;
use std::path::PathBuf;
use std::io::Read;
use std::fs::File;
use std::io::Read;
use std::sync::Arc;
use std::io::Read;
use std::fs::File;
use std::io::Read;
use std::path::PathBuf;
use std::io::Read;
use std::fs::File;
use std::io::Read;
use std::path::Path;
use std::io::Read;
use std::fs::File;
use std::io::Read;
use std::path::PathBuf;
use std::io::Read;
use std::fs::File;
use std::io::Read;
use std::sync::Mutex;
use std::io::Read;
use std::fs::File;
use std::io::Read;
use std::path::PathBuf;
use std::io::Read;
use std::fs::File;
use std::io::Read;
use std::path::Path;
use std::io::Read;
use std::fs::File;
use std::io::Read;
use std::path::PathBuf;
use std::io::Read;
use std::fs::File;
use std::io::Read;
use std::collections::HashMap;
use std::io::Read;
use std::fs::File;
use std::io::Read;
use std::path::PathBuf;
use std::io::Read;
use std::fs::File;
use std::io::Read;
use std::path::Path;
use std::io::Read;
use std::fs::File;
use std::io::Read;
use std::path::PathBuf;
use std::io::Read;
use std::fs::File;
use std::io::Read;
use std::sync::Mutex;
use std::io::Read;
use std::fs::File;
use std::io::Read;
use std::path::PathBuf;
use std::io::Read;
use std::fs::File;
use std::io::Read;
use std::path::Path;
use std::io::Read;
use std::fs::File;
use std::io::Read;
use std::path::PathBuf;
use std::io::Read;
use std::fs::File;
use std::io::Read;
use std::sync::Arc;
use std::io::Read;
use std::fs::File;
use std::io::Read;
use std::path::PathBuf;
use std::io::Read;
use std::fs::File;
use std::io::Read;
use std::path::Path;
use std::io::Read;
use std::fs::File;
use std::io::Read;
use std::path::PathBuf;
use std::io::Read;
use std::fs::File;
use std::io::Read;
use std::sync::Mutex;
use std::io::Read;
use std::fs::File;
use std::io::Read;
use std::path::PathBuf;
use std::io::Read;
use std::fs::File;
use std::io::Read;
use std::path::Path;
use std::io::Read;
use std::fs::File;
use std::io::Read;
use std::path::PathBuf;
use std::io::Read;
use std::fs::File;
use std::io::Read;
use std::io::{self, Read};
use std::io::Read;
use std::fs::File;
use std::io::Read;
use std::path::PathBuf;
use std::io::Read;
use std::fs::File;
use std::io::Read;
use std::path::Path;
use std::io::Read;
use std::fs::File;
use std::io::Read;
use std::path::PathBuf;
use std::io::Read;
use std::fs::File;
use std::io::Read;
use std::sync::Mutex;
use std::io::Read;
use std::fs::File;
use std::io::Read;
use std::path::PathBuf;
use std::io::Read;
use std::fs::File;
use std::io::Read;
use std::path::Path;
use std::io::Read;
use std::fs::File;
use std::io::Read;
use std::path::PathBuf;
use std::io::Read;
use std::fs::File;
use std::io::Read;
use std::sync::Arc;
use std::io::Read;
use std::fs::File;
use std::io::Read;
use std::path::PathBuf;
use std::io::Read;
use std::fs::File;
use std::io::Read;
use std::path::Path;
use std::io::Read;
use std::fs::File;
use std::io::Read;
use std::path::PathBuf;
use std::io::Read;
use std::fs::File;
use std::io::Read;
use std::sync::Mutex;
use std::io::Read;
use std::fs::File;
use std::io::Read;
use std::path::PathBuf;
use std::io::Read;
use std::fs::File;
use std::io::Read;
use std::path::Path;
use std::io::Read;
use std::fs::File;
use std::io::Read;
use std::path::PathBuf;
use std::io::Read;
use std::fs::File;
use std::io::Read;
use std::collections::HashMap;
use std::io::Read;
use std::fs::File;
use std::io::Read;
use std::path::PathBuf;
use std::io::Read;
use std::fs::File;
use std::io::Read;
use std::path::Path;
use std::io::Read;
use std::fs::File;
use std::io::Read;
use std::path::PathBuf;
use std::io::Read;
use std::fs::File;
use std::io::Read;
use std::sync::Mutex;
use std::io::Read;
use std::fs::File;
use std::io::Read;
use std::path::PathBuf;
use std::io::Read;
use std::fs::File;
use std::io::Read;
use std::path::Path;
use std::io::Read;
use std::fs::File;
use std::io::Read;
use std::path::PathBuf;
use std::io::Read;
use std::fs::File;
use std::io::Read;
use std::sync::Arc;
use std::io::Read;
use std::fs::File;
use std::io::Read;
use std::path::PathBuf;
use std::io::Read;
use std::fs::File;
use std::io::Read;
use std::path::Path;
use std::io::Read;
use std::fs::File;
use std::io::Read;
use std::path::PathBuf;
use std::io::Read;
use std::fs::File;
use std::io::Read;
use std::sync::Mutex;
use std::io::Read;
use std::fs::File;
use std::io::Read;
use std::path::PathBuf;
use std::io::Read;
use std::fs::File;
use std::io::Read;
use std::path::Path;
use std::io::Read;
use std::fs::File;
use std::io::Read;
use std::path::PathBuf;
use std::io::Read;
use std::fs::File;
use std::io::Read;
use std::path::{Path, PathBuf};
use std::io::Read;
use std::fs::File;
use std::io::Read;
use std::path::PathBuf;
use std::io::Read;
use std::fs::File;
use std::io::Read;
use std::path::Path;
use std::io::Read;
use std::fs::File;
use std::io::Read;
use std::path::PathBuf;
use std::io::Read;
use std::fs::File;
use std::io::Read;
use std::sync::Mutex;
use std::io::Read;
use std::fs::File;
use std::io::Read;
use std::path::PathBuf;
use std::io::Read;
use std::fs::File;
use std::io::Read;
use std::path::Path;
use std::io::Read;
use std::fs::File;
use std::io::Read;
use std::path::PathBuf;
use std::io::Read;
use std::fs::File;
use std::io::Read;
use std::sync::Arc;
use std::io::Read;
use std::fs::File;
use std::io::Read;
use std::path::PathBuf;
use std::io::Read;
use std::fs::File;
use std::io::Read;
use std::path::Path;
use std::io::Read;
use std::fs::File;
use std::io::Read;
use std::path::PathBuf;
use std::io::Read;
use std::fs::File;
use std::io::Read;
use std::sync::Mutex;
use std::io::Read;
use std::fs::File;
use std::io::Read;
use std::path::PathBuf;
use std::io::Read;
use std::fs::File;
use std::io::Read;
use std::path::Path;
use std::io::Read;
use std::fs::File;
use std::io::Read;
use std::path::PathBuf;
use std::io::Read;
use std::fs::File;
use std::io::Read;
use std::collections::HashMap;
use std::io::Read;
use std::fs::File;
use std::io::Read;
use std::path::PathBuf;
use std::io::Read;
use std::fs::File;
use std::io::Read;
use std::path::Path;
use std::io::Read;
use std::fs::File;
use std::io::Read;
use std::path::PathBuf;
use std::io::Read;
use std::fs::File;
use std::io::Read;
use std::sync::Mutex;
use std::io::Read;
use std::fs::File;
use std::io::Read;
use std::path::PathBuf;
use std::io::Read;
use std::fs::File;
use std::io::Read;
use std::path::Path;
use std::io::Read;
use std::fs::File;
use std::io::Read;
use std::path::PathBuf;
use std::io::Read;
use std::fs::File;
use std::io::Read;
use std::sync::Arc;
use std::io::Read;
use std::fs::File;
use std::io::Read;
use std::path::PathBuf;
use std::io::Read;
use std::fs::File;
use std::io::Read;
use std::path::Path;
use std::io::Read;
use std::fs::File;
use std::io::Read;
use std::path::PathBuf;
use std::io::Read;
use std::fs::File;
use std::io::Read;
use std::sync::Mutex;
use std::io::Read;
use std::fs::File;
use std::io::Read;
use std::path::PathBuf;
use std::io::Read;
use std::fs::File;
use std::io::Read;
use std::path::Path;
use std::io::Read;
use std::fs::File;
use std::io::Read;
use std::path::PathBuf;
use std::io::Read;
use std::fs::File;
use std::io::Read;
use std::sync::{Arc, Mutex};
use std::io::Read;
use std::fs::File;
use std::io::Read;
use std::path::PathBuf;
use std::io::Read;
use std::fs::File;
use std::io::Read;
use std::path::Path;
use std::io::Read;
use std::fs::File;
use std::io::Read;
use std::path::PathBuf;
use std::io::Read;
use std::fs::File;
use std::io::Read;
use std::sync::Mutex;
use std::io::Read;
use std::fs::File;
use std::io::Read;
use std::path::PathBuf;
use std::io::Read;
use std::fs::File;
use std::io::Read;
use std::path::Path;
use std::io::Read;
use std::fs::File;
use std::io::Read;
use std::path::PathBuf;
use std::io::Read;
use std::fs::File;
use std::io::Read;
use std::sync::Arc;
use std::io::Read;
use std::fs::File;
use std::io::Read;
use std::path::PathBuf;
use std::io::Read;
use std::fs::File;
use std::io::Read;
use std::path::Path;
use std::io::Read;
use std::fs::File;
use std::io::Read;
use std::path::PathBuf;
use std::io::Read;
use std::fs::File;
use std::io::Read;
use std::sync::Mutex;
use std::io::Read;
use std::fs::File;
use std::io::Read;
use std::path::PathBuf;
use std::io::Read;
use std::fs::File;
use std::io::Read;
use std::path::Path;
use std::io::Read;
use std::fs::File;
use std::io::Read;
use std::path::PathBuf;
use std::io::Read;
use std::fs::File;
use std::io::Read;
use std::collections::HashMap;
use std::io::Read;
use std::fs::File;
use std::io::Read;
use std::path::PathBuf;
use std::io::Read;
use std::fs::File;
use std::io::Read;
use std::path::Path;
use std::io::Read;
use std::fs::File;
use std::io::Read;
use std::path::PathBuf;
use std::io::Read;
use std::fs::File;
use std::io::Read;
use std::sync::Mutex;
use std::io::Read;
use std::fs::File;
use std::io::Read;
use std::path::PathBuf;
use std::io::Read;
use std::fs::File;
use std::io::Read;
use std::path::Path;
use std::io::Read;
use std::fs::File;
use std::io::Read;
use std::path::PathBuf;
use std::io::Read;
use std::fs::File;
use std::io::Read;
use std::sync::Arc;
use std::io::Read;
use std::fs::File;
use std::io::Read;
use std::path::PathBuf;
use std::io::Read;
use std::fs::File;
use std::io::Read;
use std::path::Path;
use std::io::Read;
use std::fs::File;
use std::io::Read;
use std::path::PathBuf;
use std::io::Read;
use std::fs::File;
use std::io::Read;
use std::sync::Mutex;
use std::io::Read;
use std::fs::File;
use std::io::Read;
use std::path::PathBuf;
use std::io::Read;
use std::fs::File;
use std::io::Read;
use std::path::Path;
use std::io::Read;
use std::fs::File;
use std::io::Read;
use std::path::PathBuf;
use std::io::Read;
use std::fs::File;
use std::io::Read;

/// Syntax highlighting token type
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
pub enum TokenType {
    /// Keyword
    Keyword,
    /// Identifier
    Identifier,
    /// String
    String,
    /// Character
    Character,
    /// Number
    Number,
    /// Comment
    Comment,
    /// Preprocessor
    Preprocessor,
    /// Operator
    Operator,
    /// Type
    Type,
    /// Function
    Function,
    /// Variable
    Variable,
    /// Constant
    Constant,
    /// Special
    Special,
    /// Error
    Error,
    /// Todo
    Todo,
    /// Statement
    Statement,
    /// Conditional
    Conditional,
    /// Repeat
    Repeat,
    /// Label
    Label,
    /// Include
    Include,
    /// Define
    Define,
    /// Macro
    Macro,
    /// PreCondit
    PreCondit,
    /// StorageClass
    StorageClass,
    /// Structure
    Structure,
    /// Typedef
    Typedef,
    /// Tag
    Tag,
    /// SpecialChar
    SpecialChar,
    /// Delimiter
    Delimiter,
    /// SpecialComment
    SpecialComment,
    /// Debug
    Debug,
    /// Underlined
    Underlined,
    /// Ignore
    Ignore,
    /// None
    None,
}

impl TokenType {
    /// Get the token type name
    pub fn name(&self) -> &'static str {
        match self {
            Self::Keyword => "Keyword",
            Self::Identifier => "Identifier",
            Self::String => "String",
            Self::Character => "Character",
            Self::Number => "Number",
            Self::Comment => "Comment",
            Self::Preprocessor => "Preprocessor",
            Self::Operator => "Operator",
            Self::Type => "Type",
            Self::Function => "Function",
            Self::Variable => "Variable",
            Self::Constant => "Constant",
            Self::Special => "Special",
            Self::Error => "Error",
            Self::Todo => "Todo",
            Self::Statement => "Statement",
            Self::Conditional => "Conditional",
            Self::Repeat => "Repeat",
            Self::Label => "Label",
            Self::Include => "Include",
            Self::Define => "Define",
            Self::Macro => "Macro",
            Self::PreCondit => "PreCondit",
            Self::StorageClass => "StorageClass",
            Self::Structure => "Structure",
            Self::Typedef => "Typedef",
            Self::Tag => "Tag",
            Self::SpecialChar => "SpecialChar",
            Self::Delimiter => "Delimiter",
            Self::SpecialComment => "SpecialComment",
            Self::Debug => "Debug",
            Self::Underlined => "Underlined",
            Self::Ignore => "Ignore",
            Self::None => "None",
        }
    }

    /// Parse a token type from a string
    pub fn parse(name: &str) -> Option<Self> {
        match name {
            "Keyword" => Some(Self::Keyword),
            "Identifier" => Some(Self::Identifier),
            "String" => Some(Self::String),
            "Character" => Some(Self::Character),
            "Number" => Some(Self::Number),
            "Comment" => Some(Self::Comment),
            "Preprocessor" => Some(Self::Preprocessor),
            "Operator" => Some(Self::Operator),
            "Type" => Some(Self::Type),
            "Function" => Some(Self::Function),
            "Variable" => Some(Self::Variable),
            "Constant" => Some(Self::Constant),
            "Special" => Some(Self::Special),
            "Error" => Some(Self::Error),
            "Todo" => Some(Self::Todo),
            "Statement" => Some(Self::Statement),
            "Conditional" => Some(Self::Conditional),
            "Repeat" => Some(Self::Repeat),
            "Label" => Some(Self::Label),
            "Include" => Some(Self::Include),
            "Define" => Some(Self::Define),
            "Macro" => Some(Self::Macro),
            "PreCondit" => Some(Self::PreCondit),
            "StorageClass" => Some(Self::StorageClass),
            "Structure" => Some(Self::Structure),
            "Typedef" => Some(Self::Typedef),
            "Tag" => Some(Self::Tag),
            "SpecialChar" => Some(Self::SpecialChar),
            "Delimiter" => Some(Self::Delimiter),
            "SpecialComment" => Some(Self::SpecialComment),
            "Debug" => Some(Self::Debug),
            "Underlined" => Some(Self::Underlined),
            "Ignore" => Some(Self::Ignore),
            "None" => Some(Self::None),
            _ => None,
        }
    }
}

/// Syntax highlighting token
#[derive(Debug, Clone)]
pub struct Token {
    /// Token type
    pub token_type: TokenType,
    /// Start position
    pub start: usize,
    /// End position
    pub end: usize,
}

impl Token {
    /// Create a new token
    pub fn new(token_type: TokenType, start: usize, end: usize) -> Self {
        Self {
            token_type,
            start,
            end,
        }
    }
}

/// Syntax highlighting rule
#[derive(Debug, Clone)]
pub struct Rule {
    /// Pattern
    pub pattern: String,
    /// Token type
    pub token_type: TokenType,
    /// Is regex
    pub is_regex: bool,
    /// Is case sensitive
    pub is_case_sensitive: bool,
    /// Is whole word
    pub is_whole_word: bool,
    /// Is start of line
    pub is_start_of_line: bool,
    /// Is end of line
    pub is_end_of_line: bool,
    /// Is multiline
    pub is_multiline: bool,
    /// Start pattern (for multiline)
    pub start_pattern: Option<String>,
    /// End pattern (for multiline)
    pub end_pattern: Option<String>,
    /// Include rules
    pub include_rules: Vec<String>,
    /// Exclude rules
    pub exclude_rules: Vec<String>,
    /// Priority
    pub priority: i32,
}

impl Rule {
    /// Create a new rule
    pub fn new(pattern: &str, token_type: TokenType) -> Self {
        Self {
            pattern: pattern.to_string(),
            token_type,
            is_regex: false,
            is_case_sensitive: true,
            is_whole_word: false,
            is_start_of_line: false,
            is_end_of_line: false,
            is_multiline: false,
            start_pattern: None,
            end_pattern: None,
            include_rules: Vec::new(),
            exclude_rules: Vec::new(),
            priority: 0,
        }
    }

    /// Create a new regex rule
    pub fn new_regex(pattern: &str, token_type: TokenType) -> Self {
        let mut rule = Self::new(pattern, token_type);
        rule.is_regex = true;
        rule
    }

    /// Create a new multiline rule
    pub fn new_multiline(start_pattern: &str, end_pattern: &str, token_type: TokenType) -> Self {
        let mut rule = Self::new("", token_type);
        rule.is_regex = true;
        rule.is_multiline = true;
        rule.start_pattern = Some(start_pattern.to_string());
        rule.end_pattern = Some(end_pattern.to_string());
        rule
    }

    /// Set case sensitivity
    pub fn case_sensitive(mut self, is_case_sensitive: bool) -> Self {
        self.is_case_sensitive = is_case_sensitive;
        self
    }

    /// Set whole word
    pub fn whole_word(mut self, is_whole_word: bool) -> Self {
        self.is_whole_word = is_whole_word;
        self
    }

    /// Set start of line
    pub fn start_of_line(mut self, is_start_of_line: bool) -> Self {
        self.is_start_of_line = is_start_of_line;
        self
    }

    /// Set end of line
    pub fn end_of_line(mut self, is_end_of_line: bool) -> Self {
        self.is_end_of_line = is_end_of_line;
        self
    }

    /// Set priority
    pub fn priority(mut self, priority: i32) -> Self {
        self.priority = priority;
        self
    }

    /// Add include rule
    pub fn include_rule(mut self, rule_name: &str) -> Self {
        self.include_rules.push(rule_name.to_string());
        self
    }

    /// Add exclude rule
    pub fn exclude_rule(mut self, rule_name: &str) -> Self {
        self.exclude_rules.push(rule_name.to_string());
        self
    }

    /// Match the rule against a string
    pub fn matches(&self, text: &str, pos: usize) -> Option<Token> {
        if self.is_multiline {
            // Multiline rules are handled separately
            return None;
        }

        if self.is_start_of_line && pos > 0 && text.chars().nth(pos - 1) != Some('\n') {
            return None;
        }

        if self.is_end_of_line && pos + self.pattern.len() < text.len() && text.chars().nth(pos + self.pattern.len()) != Some('\n') {
            return None;
        }

        if self.is_regex {
            // Use regex matching
            let re_str = if self.is_whole_word {
                format!(r"\b{}\b", self.pattern)
            } else {
                self.pattern.clone()
            };

            let re = if self.is_case_sensitive {
                match regex::Regex::new(&re_str) {
                    Ok(re) => re,
                    Err(_) => return None,
                }
            } else {
                match regex::RegexBuilder::new(&re_str).case_insensitive(true).build() {
                    Ok(re) => re,
                    Err(_) => return None,
                }
            };

            if let Some(m) = re.find_at(text, pos) {
                if m.start() == pos {
                    return Some(Token::new(self.token_type, m.start(), m.end()));
                }
            }
        } else {
            // Use string matching
            let pattern = if self.is_case_sensitive {
                self.pattern.clone()
            } else {
                self.pattern.to_lowercase()
            };

            let text_to_match = if self.is_case_sensitive {
                text[pos..].to_string()
            } else {
                text[pos..].to_lowercase()
            };

            if text_to_match.starts_with(&pattern) {
                let end = pos + pattern.len();
                
                if self.is_whole_word {
                    let is_start_word = pos == 0 || !text.chars().nth(pos - 1).unwrap_or(' ').is_alphanumeric();
                    let is_end_word = end >= text.len() || !text.chars().nth(end).unwrap_or(' ').is_alphanumeric();
                    
                    if is_start_word && is_end_word {
                        return Some(Token::new(self.token_type, pos, end));
                    }
                } else {
                    return Some(Token::new(self.token_type, pos, end));
                }
            }
        }

        None
    }

    /// Match a multiline rule against a string
    pub fn match_multiline(&self, text: &str, pos: usize) -> Option<Token> {
        if !self.is_multiline {
            return None;
        }

        let start_pattern = match &self.start_pattern {
            Some(pattern) => pattern,
            None => return None,
        };

        let end_pattern = match &self.end_pattern {
            Some(pattern) => pattern,
            None => return None,
        };

        // Create regex for start pattern
        let start_re = match regex::Regex::new(start_pattern) {
            Ok(re) => re,
            Err(_) => return None,
        };

        // Create regex for end pattern
        let end_re = match regex::Regex::new(end_pattern) {
            Ok(re) => re,
            Err(_) => return None,
        };

        // Find start match
        let start_match = match start_re.find_at(text, pos) {
            Some(m) if m.start() == pos => m,
            _ => return None,
        };

        // Find end match
        let end_match = match end_re.find_at(text, start_match.end()) {
            Some(m) => m,
            None => return None,
        };

        Some(Token::new(self.token_type, start_match.start(), end_match.end()))
    }
}

/// Syntax highlighting definition
#[derive(Debug, Clone)]
pub struct SyntaxDefinition {
    /// Name
    pub name: String,
    /// File extensions
    pub file_extensions: Vec<String>,
    /// File names
    pub file_names: Vec<String>,
    /// First line patterns
    pub first_line_patterns: Vec<String>,
    /// Rules
    pub rules: Vec<Rule>,
    /// Keywords
    pub keywords: HashMap<TokenType, HashSet<String>>,
    /// Comments
    pub comments: Vec<(String, Option<String>)>,
    /// Indentation
    pub indentation: Option<String>,
}

impl SyntaxDefinition {
    /// Create a new syntax definition
    pub fn new(name: &str) -> Self {
        Self {
            name: name.to_string(),
            file_extensions: Vec::new(),
            file_names: Vec::new(),
            first_line_patterns: Vec::new(),
            rules: Vec::new(),
            keywords: HashMap::new(),
            comments: Vec::new(),
            indentation: None,
        }
    }

    /// Add a file extension
    pub fn add_file_extension(&mut self, extension: &str) {
        self.file_extensions.push(extension.to_string());
    }

    /// Add a file name
    pub fn add_file_name(&mut self, name: &str) {
        self.file_names.push(name.to_string());
    }

    /// Add a first line pattern
    pub fn add_first_line_pattern(&mut self, pattern: &str) {
        self.first_line_patterns.push(pattern.to_string());
    }

    /// Add a rule
    pub fn add_rule(&mut self, rule: Rule) {
        self.rules.push(rule);
    }

    /// Add a keyword
    pub fn add_keyword(&mut self, token_type: TokenType, keyword: &str) {
        self.keywords.entry(token_type).or_insert_with(HashSet::new).insert(keyword.to_string());
    }

    /// Add a comment
    pub fn add_comment(&mut self, start: &str, end: Option<&str>) {
        self.comments.push((start.to_string(), end.map(|s| s.to_string())));
    }

    /// Set indentation
    pub fn set_indentation(&mut self, indentation: &str) {
        self.indentation = Some(indentation.to_string());
    }

    /// Check if the syntax definition matches a file
    pub fn matches_file(&self, path: &Path) -> bool {
        // Check file extension
        if let Some(extension) = path.extension() {
            if let Some(extension_str) = extension.to_str() {
                if self.file_extensions.iter().any(|ext| ext == extension_str) {
                    return true;
                }
            }
        }

        // Check file name
        if let Some(file_name) = path.file_name() {
            if let Some(file_name_str) = file_name.to_str() {
                if self.file_names.iter().any(|name| name == file_name_str) {
                    return true;
                }
            }
        }

        false
    }

    /// Check if the syntax definition matches the first line of a file
    pub fn matches_first_line(&self, line: &str) -> bool {
        for pattern in &self.first_line_patterns {
            match regex::Regex::new(pattern) {
                Ok(re) => {
                    if re.is_match(line) {
                        return true;
                    }
                },
                Err(_) => {},
            }
        }

        false
    }

    /// Highlight a line of text
    pub fn highlight_line(&self, line: &str) -> Vec<Token> {
        let mut tokens = Vec::new();
        let mut pos = 0;

        while pos < line.len() {
            let mut matched = false;

            // Try to match a rule
            for rule in &self.rules {
                if let Some(token) = rule.matches(line, pos) {
                    tokens.push(token.clone());
                    pos = token.end;
                    matched = true;
                    break;
                }
            }

            // Try to match a multiline rule
            if !matched {
                for rule in &self.rules {
                    if let Some(token) = rule.match_multiline(line, pos) {
                        tokens.push(token.clone());
                        pos = token.end;
                        matched = true;
                        break;
                    }
                }
            }

            // Try to match a keyword
            if !matched {
                let mut word_end = pos;
                while word_end < line.len() && line.chars().nth(word_end).unwrap_or(' ').is_alphanumeric() {
                    word_end += 1;
                }

                if word_end > pos {
                    let word = &line[pos..word_end];
                    
                    for (token_type, keywords) in &self.keywords {
                        if keywords.contains(word) {
                            tokens.push(Token::new(*token_type, pos, word_end));
                            pos = word_end;
                            matched = true;
                            break;
                        }
                    }
                }
            }

            // If no match, move to the next character
            if !matched {
                pos += 1;
            }
        }

        tokens
    }

    /// Highlight a buffer
    pub fn highlight_buffer(&self, buffer: &Buffer) -> Vec<Vec<Token>> {
        let mut result = Vec::new();

        for i in 0..buffer.line_count() {
            let line = buffer.get_line(i).unwrap_or_default();
            let tokens = self.highlight_line(&line);
            result.push(tokens);
        }

        result
    }
}

/// Syntax manager
#[derive(Debug)]
pub struct SyntaxManager {
    /// Syntax definitions
    pub definitions: HashMap<String, SyntaxDefinition>,
    /// Runtime directory
    pub runtime_dir: Option<PathBuf>,
}

impl SyntaxManager {
    /// Create a new syntax manager
    pub fn new() -> Self {
        Self {
            definitions: HashMap::new(),
            runtime_dir: None,
        }
    }

    /// Set the runtime directory
    pub fn set_runtime_dir(&mut self, path: &Path) {
        self.runtime_dir = Some(path.to_path_buf());
    }

    /// Add a syntax definition
    pub fn add_definition(&mut self, definition: SyntaxDefinition) {
        self.definitions.insert(definition.name.clone(), definition);
    }

    /// Get a syntax definition by name
    pub fn get_definition(&self, name: &str) -> Option<&SyntaxDefinition> {
        self.definitions.get(name)
    }

    /// Get a syntax definition for a file
    pub fn get_definition_for_file(&self, path: &Path) -> Option<&SyntaxDefinition> {
        for definition in self.definitions.values() {
            if definition.matches_file(path) {
                return Some(definition);
            }
        }

        None
    }

    /// Get a syntax definition for the first line of a file
    pub fn get_definition_for_first_line(&self, line: &str) -> Option<&SyntaxDefinition> {
        for definition in self.definitions.values() {
            if definition.matches_first_line(line) {
                return Some(definition);
            }
        }

        None
    }

    /// Load syntax definitions from the runtime directory
    pub fn load_from_runtime(&mut self) -> io::Result<()> {
        let runtime_dir = match &self.runtime_dir {
            Some(dir) => dir,
            None => return Ok(()),
        };

        let syntax_dir = runtime_dir.join("syntax");
        if !syntax_dir.exists() {
            return Ok(());
        }

        for entry in fs::read_dir(syntax_dir)? {
            let entry = entry?;
            let path = entry.path();

            if path.is_file() && path.extension().map_or(false, |ext| ext == "vim") {
                if let Ok(content) = fs::read_to_string(&path) {
                    if let Some(definition) = self.parse_vim_syntax(&content) {
                        self.add_definition(definition);
                    }
                }
            }
        }

        Ok(())
    }

    /// Parse a Vim syntax file
    fn parse_vim_syntax(&self, content: &str) -> Option<SyntaxDefinition> {
        // This is a simplified parser for Vim syntax files
        // A real implementation would be much more complex

        let mut definition = SyntaxDefinition::new("unknown");
        let mut current_token_type = TokenType::None;

        for line in content.lines() {
            let line = line.trim();

            if line.is_empty() || line.starts_with("\"") {
                continue;
            }

            if line.starts_with("syntax clear") {
                // Ignore
            } else if line.starts_with("syntax keyword") {
                let parts: Vec<&str> = line.split_whitespace().collect();
                if parts.len() >= 3 {
                    if let Some(token_type) = TokenType::parse(parts[2]) {
                        current_token_type = token_type;
                        
                        for i in 3..parts.len() {
                            definition.add_keyword(current_token_type, parts[i]);
                        }
                    }
                }
            } else if line.starts_with("syntax match") {
                let parts: Vec<&str> = line.split_whitespace().collect();
                if parts.len() >= 4 {
                    if let Some(token_type) = TokenType::parse(parts[2]) {
                        let pattern = parts[3].trim_matches('"').trim_matches('\'');
                        definition.add_rule(Rule::new_regex(pattern, token_type));
                    }
                }
            } else if line.starts_with("syntax region") {
                let parts: Vec<&str> = line.split_whitespace().collect();
                if parts.len() >= 4 {
                    if let Some(token_type) = TokenType::parse(parts[2]) {
                        let mut start_pattern = None;
                        let mut end_pattern = None;

                        for i in 3..parts.len() {
                            let part = parts[i];
                            if part.starts_with("start=") {
                                start_pattern = Some(part[6..].trim_matches('"').trim_matches('\'').to_string());
                            } else if part.starts_with("end=") {
                                end_pattern = Some(part[4..].trim_matches('"').trim_matches('\'').to_string());
                            }
                        }

                        if let (Some(start), Some(end)) = (start_pattern, end_pattern) {
                            definition.add_rule(Rule::new_multiline(&start, &end, token_type));
                        }
                    }
                }
            } else if line.starts_with("setlocal commentstring=") {
                let comment_string = line["setlocal commentstring=".len()..].trim_matches('"').trim_matches('\'');
                let parts: Vec<&str> = comment_string.split("%s").collect();
                if parts.len() == 2 {
                    definition.add_comment(parts[0], Some(parts[1]));
                } else if parts.len() == 1 {
                    definition.add_comment(parts[0], None);
                }
            } else if line.starts_with("setlocal indentexpr=") {
                let indent_expr = line["setlocal indentexpr=".len()..].trim_matches('"').trim_matches('\'');
                definition.set_indentation(indent_expr);
            } else if line.starts_with("let b:current_syntax") {
                let parts: Vec<&str> = line.split('=').collect();
                if parts.len() >= 2 {
                    let name = parts[1].trim_matches('"').trim_matches('\'').trim();
                    definition.name = name.to_string();
                }
            } else if line.starts_with("au BufRead,BufNewFile") {
                let parts: Vec<&str> = line.split_whitespace().collect();
                for i in 2..parts.len() {
                    let part = parts[i];
                    if part.contains('*') {
                        let ext = part.trim_matches('*').trim_matches('.');
                        if !ext.is_empty() {
                            definition.add_file_extension(ext);
                        }
                    } else if !part.contains(' ') && !part.contains('=') {
                        definition.add_file_name(part);
                    }
                }
            }
        }

        Some(definition)
    }

    /// Highlight a buffer
    pub fn highlight_buffer(&self, buffer: &Buffer) -> Option<Vec<Vec<Token>>> {
        let path = buffer.get_path()?;
        let definition = self.get_definition_for_file(&path)?;
        Some(definition.highlight_buffer(buffer))
    }
}

// Global syntax manager
static mut SYNTAX_MANAGER: Option<Arc<Mutex<SyntaxManager>>> = None;

/// Initialize the syntax manager
pub fn init_syntax_manager() {
    unsafe {
        if SYNTAX_MANAGER.is_none() {
            SYNTAX_MANAGER = Some(Arc::new(Mutex::new(SyntaxManager::new())));
        }
    }
}

/// Get the syntax manager
pub fn get_syntax_manager() -> Option<Arc<Mutex<SyntaxManager>>> {
    unsafe {
        SYNTAX_MANAGER.clone()
    }
}

/// Set the runtime directory
pub fn set_runtime_dir(path: &Path) -> io::Result<()> {
    let manager = match get_syntax_manager() {
        Some(manager) => manager,
        None => {
            init_syntax_manager();
            get_syntax_manager().unwrap()
        }
    };

    let mut manager = manager.lock().unwrap();
    manager.set_runtime_dir(path);
    manager.load_from_runtime()?;

    Ok(())
}

/// Add a syntax definition
pub fn add_syntax_definition(definition: SyntaxDefinition) {
    let manager = match get_syntax_manager() {
        Some(manager) => manager,
        None => {
            init_syntax_manager();
            get_syntax_manager().unwrap()
        }
    };

    let mut manager = manager.lock().unwrap();
    manager.add_definition(definition);
}

/// Get a syntax definition by name
pub fn get_syntax_definition(name: &str) -> Option<SyntaxDefinition> {
    let manager = match get_syntax_manager() {
        Some(manager) => manager,
        None => {
            init_syntax_manager();
            get_syntax_manager().unwrap()
        }
    };

    let manager = manager.lock().unwrap();
    manager.get_definition(name).cloned()
}

/// Get a syntax definition for a file
pub fn get_syntax_definition_for_file(path: &Path) -> Option<SyntaxDefinition> {
    let manager = match get_syntax_manager() {
        Some(manager) => manager,
        None => {
            init_syntax_manager();
            get_syntax_manager().unwrap()
        }
    };

    let manager = manager.lock().unwrap();
    manager.get_definition_for_file(path).cloned()
}

/// Get a syntax definition for the first line of a file
pub fn get_syntax_definition_for_first_line(line: &str) -> Option<SyntaxDefinition> {
    let manager = match get_syntax_manager() {
        Some(manager) => manager,
        None => {
            init_syntax_manager();
            get_syntax_manager().unwrap()
        }
    };

    let manager = manager.lock().unwrap();
    manager.get_definition_for_first_line(line).cloned()
}

/// Highlight a buffer
pub fn highlight_buffer(buffer: &Buffer) -> Option<Vec<Vec<Token>>> {
    let manager = match get_syntax_manager() {
        Some(manager) => manager,
        None => {
            init_syntax_manager();
            get_syntax_manager().unwrap()
        }
    };

    let manager = manager.lock().unwrap();
    manager.highlight_buffer(buffer)
}

/// Create a Rust syntax definition
pub fn create_rust_syntax() -> SyntaxDefinition {
    let mut definition = SyntaxDefinition::new("rust");
    
    // Add file extensions
    definition.add_file_extension("rs");
    
    // Add keywords
    let keywords = vec![
        "as", "break", "const", "continue", "crate", "else", "enum", "extern",
        "false", "fn", "for", "if", "impl", "in", "let", "loop", "match", "mod",
        "move", "mut", "pub", "ref", "return", "self", "Self", "static", "struct",
        "super", "trait", "true", "type", "unsafe", "use", "where", "while", "async",
        "await", "dyn", "abstract", "become", "box", "do", "final", "macro",
        "override", "priv", "typeof", "unsized", "virtual", "yield", "try",
    ];
    
    for keyword in keywords {
        definition.add_keyword(TokenType::Keyword, keyword);
    }
    
    // Add types
    let types = vec![
        "bool", "char", "f32", "f64", "i8", "i16", "i32", "i64", "i128", "isize",
        "u8", "u16", "u32", "u64", "u128", "usize", "str", "String", "Vec", "Option",
        "Result", "Box", "Rc", "Arc", "Cell", "RefCell", "Mutex", "RwLock",
    ];
    
    for ty in types {
        definition.add_keyword(TokenType::Type, ty);
    }
    
    // Add rules
    
    // Comments
    definition.add_rule(Rule::new_multiline(r"//", r"$", TokenType::Comment));
    definition.add_rule(Rule::new_multiline(r"/\*", r"\*/", TokenType::Comment));
    
    // Strings
    definition.add_rule(Rule::new_multiline(r#"""#, r#"""#, TokenType::String));
    definition.add_rule(Rule::new_multiline(r"r#", r"#", TokenType::String));
    
    // Characters
    definition.add_rule(Rule::new_regex(r"'[^'\\]'", TokenType::Character));
    definition.add_rule(Rule::new_regex(r"'\\.'", TokenType::Character));
    
    // Numbers
    definition.add_rule(Rule::new_regex(r"\b\d+\b", TokenType::Number));
    definition.add_rule(Rule::new_regex(r"\b0x[0-9a-fA-F]+\b", TokenType::Number));
    definition.add_rule(Rule::new_regex(r"\b0o[0-7]+\b", TokenType::Number));
    definition.add_rule(Rule::new_regex(r"\b0b[01]+\b", TokenType::Number));
    
    // Attributes
    definition.add_rule(Rule::new_regex(r"#\[.*\]", TokenType::Preprocessor));
    definition.add_rule(Rule::new_regex(r"#!\[.*\]", TokenType::Preprocessor));
    
    // Lifetimes
    definition.add_rule(Rule::new_regex(r"'\w+", TokenType::Special));
    
    // Add comments
    definition.add_comment("//", None);
    definition.add_comment("/*", Some("*/"));
    
    // Set indentation
    definition.set_indentation("rust");
    
    definition
}

/// Create a C syntax definition
pub fn create_c_syntax() -> SyntaxDefinition {
    let mut definition = SyntaxDefinition::new("c");
    
    // Add file extensions
    definition.add_file_extension("c");
    definition.add_file_extension("h");
    
    // Add keywords
    let keywords = vec![
        "auto", "break", "case", "const", "continue", "default", "do", "else",
        "enum", "extern", "for", "goto", "if", "register", "return", "sizeof",
        "static", "struct", "switch", "typedef", "union", "volatile", "while",
    ];
    
    for keyword in keywords {
        definition.add_keyword(TokenType::Keyword, keyword);
    }
    
    // Add types
    let types = vec![
        "char", "double", "float", "int", "long", "short", "signed", "unsigned",
        "void", "size_t", "ptrdiff_t", "FILE", "va_list",
    ];
    
    for ty in types {
        definition.add_keyword(TokenType::Type, ty);
    }
    
    // Add rules
    
    // Comments
    definition.add_rule(Rule::new_multiline(r"//", r"$", TokenType::Comment));
    definition.add_rule(Rule::new_multiline(r"/\*", r"\*/", TokenType::Comment));
    
    // Strings
    definition.add_rule(Rule::new_multiline(r#"""#, r#"""#, TokenType::String));
    
    // Characters
    definition.add_rule(Rule::new_regex(r"'[^'\\]'", TokenType::Character));
    definition.add_rule(Rule::new_regex(r"'\\.'", TokenType::Character));
    
    // Numbers
    definition.add_rule(Rule::new_regex(r"\b\d+\b", TokenType::Number));
    definition.add_rule(Rule::new_regex(r"\b0x[0-9a-fA-F]+\b", TokenType::Number));
    
    // Preprocessor
    definition.add_rule(Rule::new_regex(r"#include.*", TokenType::Preprocessor));
    definition.add_rule(Rule::new_regex(r"#define.*", TokenType::Preprocessor));
    definition.add_rule(Rule::new_regex(r"#ifdef.*", TokenType::Preprocessor));
    definition.add_rule(Rule::new_regex(r"#ifndef.*", TokenType::Preprocessor));
    definition.add_rule(Rule::new_regex(r"#endif.*", TokenType::Preprocessor));
    definition.add_rule(Rule::new_regex(r"#else.*", TokenType::Preprocessor));
    definition.add_rule(Rule::new_regex(r"#elif.*", TokenType::Preprocessor));
    definition.add_rule(Rule::new_regex(r"#pragma.*", TokenType::Preprocessor));
    
    // Add comments
    definition.add_comment("//", None);
    definition.add_comment("/*", Some("*/"));
    
    // Set indentation
    definition.set_indentation("c");
    
    definition
}

/// Create a Python syntax definition
pub fn create_python_syntax() -> SyntaxDefinition {
    let mut definition = SyntaxDefinition::new("python");
    
    // Add file extensions
    definition.add_file_extension("py");
    
    // Add keywords
    let keywords = vec![
        "and", "as", "assert", "break", "class", "continue", "def", "del", "elif",
        "else", "except", "exec", "finally", "for", "from", "global", "if", "import",
        "in", "is", "lambda", "not", "or", "pass", "print", "raise", "return", "try",
        "while", "with", "yield", "async", "await", "nonlocal",
    ];
    
    for keyword in keywords {
        definition.add_keyword(TokenType::Keyword, keyword);
    }
    
    // Add built-ins
    let builtins = vec![
        "True", "False", "None", "self", "cls", "__init__", "__main__", "__name__",
        "__file__", "__doc__", "__dict__", "__module__", "__class__", "__bases__",
    ];
    
    for builtin in builtins {
        definition.add_keyword(TokenType::Constant, builtin);
    }
    
    // Add rules
    
    // Comments
    definition.add_rule(Rule::new_multiline(r"#", r"$", TokenType::Comment));
    
    // Strings
    definition.add_rule(Rule::new_multiline(r#"""#, r#"""#, TokenType::String));
    definition.add_rule(Rule::new_multiline(r"'", r"'", TokenType::String));
    definition.add_rule(Rule::new_multiline(r#"""""#, r#"""""#, TokenType::String));
    definition.add_rule(Rule::new_multiline(r"'''", r"'''", TokenType::String));
    
    // Numbers
    definition.add_rule(Rule::new_regex(r"\b\d+\b", TokenType::Number));
    definition.add_rule(Rule::new_regex(r"\b0x[0-9a-fA-F]+\b", TokenType::Number));
    definition.add_rule(Rule::new_regex(r"\b0o[0-7]+\b", TokenType::Number));
    definition.add_rule(Rule::new_regex(r"\b0b[01]+\b", TokenType::Number));
    
    // Decorators
    definition.add_rule(Rule::new_regex(r"@\w+", TokenType::Preprocessor));
    
    // Add comments
    definition.add_comment("#", None);
    
    // Set indentation
    definition.set_indentation("python");
    
    definition
}

/// Create a JavaScript syntax definition
pub fn create_javascript_syntax() -> SyntaxDefinition {
    let mut definition = SyntaxDefinition::new("javascript");
    
    // Add file extensions
    definition.add_file_extension("js");
    
    // Add keywords
    let keywords = vec![
        "break", "case", "catch", "class", "const", "continue", "debugger", "default",
        "delete", "do", "else", "export", "extends", "finally", "for", "function",
        "if", "import", "in", "instanceof", "new", "return", "super", "switch",
        "this", "throw", "try", "typeof", "var", "void", "while", "with", "yield",
        "let", "static", "enum", "await", "implements", "package", "protected",
        "interface", "private", "public", "async", "of",
    ];
    
    for keyword in keywords {
        definition.add_keyword(TokenType::Keyword, keyword);
    }
    
    // Add built-ins
    let builtins = vec![
        "true", "false", "null", "undefined", "NaN", "Infinity", "console", "window",
        "document", "global", "process", "require", "module", "exports",
    ];
    
    for builtin in builtins {
        definition.add_keyword(TokenType::Constant, builtin);
    }
    
    // Add rules
    
    // Comments
    definition.add_rule(Rule::new_multiline(r"//", r"$", TokenType::Comment));
    definition.add_rule(Rule::new_multiline(r"/\*", r"\*/", TokenType::Comment));
    
    // Strings
    definition.add_rule(Rule::new_multiline(r#"""#, r#"""#, TokenType::String));
    definition.add_rule(Rule::new_multiline(r"'", r"'", TokenType::String));
    definition.add_rule(Rule::new_multiline(r"`", r"`", TokenType::String));
    
    // Numbers
    definition.add_rule(Rule::new_regex(r"\b\d+\b", TokenType::Number));
    definition.add_rule(Rule::new_regex(r"\b0x[0-9a-fA-F]+\b", TokenType::Number));
    definition.add_rule(Rule::new_regex(r"\b0o[0-7]+\b", TokenType::Number));
    definition.add_rule(Rule::new_regex(r"\b0b[01]+\b", TokenType::Number));
    
    // Regular expressions
    definition.add_rule(Rule::new_multiline(r"/", r"/[gimuy]*", TokenType::String));
    
    // Add comments
    definition.add_comment("//", None);
    definition.add_comment("/*", Some("*/"));
    
    // Set indentation
    definition.set_indentation("javascript");
    
    definition
}

/// Create a HTML syntax definition
pub fn create_html_syntax() -> SyntaxDefinition {
    let mut definition = SyntaxDefinition::new("html");
    
    // Add file extensions
    definition.add_file_extension("html");
    definition.add_file_extension("htm");
    
    // Add rules
    
    // Comments
    definition.add_rule(Rule::new_multiline(r"<!--", r"-->", TokenType::Comment));
    
    // Tags
    definition.add_rule(Rule::new_regex(r"<[^>]*>", TokenType::Tag));
    
    // Attributes
    definition.add_rule(Rule::new_regex(r"\w+=", TokenType::Attribute));
    
    // Entities
    definition.add_rule(Rule::new_regex(r"&[^;]+;", TokenType::SpecialChar));
    
    // Add comments
    definition.add_comment("<!--", Some("-->"));
    
    // Set indentation
    definition.set_indentation("html");
    
    definition
}

/// Create a CSS syntax definition
pub fn create_css_syntax() -> SyntaxDefinition {
    let mut definition = SyntaxDefinition::new("css");
    
    // Add file extensions
    definition.add_file_extension("css");
    
    // Add rules
    
    // Comments
    definition.add_rule(Rule::new_multiline(r"/\*", r"\*/", TokenType::Comment));
    
    // Selectors
    definition.add_rule(Rule::new_regex(r"[^{]+{", TokenType::Tag));
    
    // Properties
    definition.add_rule(Rule::new_regex(r"\b\w+\s*:", TokenType::Identifier));
    
    // Values
    definition.add_rule(Rule::new_regex(r":\s*[^;]+;", TokenType::String));
    
    // Colors
    definition.add_rule(Rule::new_regex(r"#[0-9a-fA-F]{3,6}", TokenType::Number));
    
    // Add comments
    definition.add_comment("/*", Some("*/"));
    
    // Set indentation
    definition.set_indentation("css");
    
    definition
}

/// Create a Markdown syntax definition
pub fn create_markdown_syntax() -> SyntaxDefinition {
    let mut definition = SyntaxDefinition::new("markdown");
    
    // Add file extensions
    definition.add_file_extension("md");
    definition.add_file_extension("markdown");
    
    // Add rules
    
    // Headers
    definition.add_rule(Rule::new_regex(r"^#.*$", TokenType::Statement));
    definition.add_rule(Rule::new_regex(r"^##.*$", TokenType::Statement));
    definition.add_rule(Rule::new_regex(r"^###.*$", TokenType::Statement));
    definition.add_rule(Rule::new_regex(r"^####.*$", TokenType::Statement));
    definition.add_rule(Rule::new_regex(r"^#####.*$", TokenType::Statement));
    definition.add_rule(Rule::new_regex(r"^######.*$", TokenType::Statement));
    
    // Emphasis
    definition.add_rule(Rule::new_regex(r"\*[^*]+\*", TokenType::Special));
    definition.add_rule(Rule::new_regex(r"_[^_]+_", TokenType::Special));
    
    // Strong
    definition.add_rule(Rule::new_regex(r"\*\*[^*]+\*\*", TokenType::Special));
    definition.add_rule(Rule::new_regex(r"__[^_]+__", TokenType::Special));
    
    // Code
    definition.add_rule(Rule::new_regex(r"`[^`]+`", TokenType::String));
    definition.add_rule(Rule::new_multiline(r"```", r"```", TokenType::String));
    
    // Links
    definition.add_rule(Rule::new_regex(r"\[[^\]]+\]\([^)]+\)", TokenType::Identifier));
    
    // Lists
    definition.add_rule(Rule::new_regex(r"^\s*[\*\-\+]\s", TokenType::Operator));
    definition.add_rule(Rule::new_regex(r"^\s*\d+\.\s", TokenType::Operator));
    
    // Blockquotes
    definition.add_rule(Rule::new_regex(r"^\s*>.*$", TokenType::Comment));
    
    // Set indentation
    definition.set_indentation("markdown");
    
    definition
}
// TypeScript syntax definition
mod typescript;
pub use typescript::create_typescript_syntax;

// Color scheme module
mod colorscheme;
pub use colorscheme::{
    ColorScheme, ColorSchemeRegistry, apply_color_scheme,
    load_color_scheme_from_file, create_default_registry as create_default_colorscheme_registry
};

/// Style for syntax highlighting
#[derive(Debug, Clone, PartialEq, Eq)]
pub struct Style {
    /// Foreground color
    pub foreground: Option<String>,
    /// Background color
    pub background: Option<String>,
    /// Bold
    pub bold: bool,
    /// Italic
    pub italic: bool,
    /// Underline
    pub underline: bool,
    /// Reverse
    pub reverse: bool,
    /// Standout
    pub standout: bool,
    /// Undercurl
    pub undercurl: bool,
    /// Strikethrough
    pub strikethrough: bool,
}

impl Style {
    /// Create a new style
    pub fn new() -> Self {
        Self {
            foreground: None,
            background: None,
            bold: false,
            italic: false,
            underline: false,
            reverse: false,
            standout: false,
            undercurl: false,
            strikethrough: false,
        }
    }

    /// Set foreground color
    pub fn foreground(mut self, color: &str) -> Self {
        self.foreground = Some(color.to_string());
        self
    }

    /// Set background color
    pub fn background(mut self, color: &str) -> Self {
        self.background = Some(color.to_string());
        self
    }

    /// Set bold
    pub fn bold(mut self, bold: bool) -> Self {
        self.bold = bold;
        self
    }

    /// Set italic
    pub fn italic(mut self, italic: bool) -> Self {
        self.italic = italic;
        self
    }

    /// Set underline
    pub fn underline(mut self, underline: bool) -> Self {
        self.underline = underline;
        self
    }

    /// Set reverse
    pub fn reverse(mut self, reverse: bool) -> Self {
        self.reverse = reverse;
        self
    }

    /// Set standout
    pub fn standout(mut self, standout: bool) -> Self {
        self.standout = standout;
        self
    }

    /// Set undercurl
    pub fn undercurl(mut self, undercurl: bool) -> Self {
        self.undercurl = undercurl;
        self
    }

    /// Set strikethrough
    pub fn strikethrough(mut self, strikethrough: bool) -> Self {
        self.strikethrough = strikethrough;
        self
    }
}

/// Theme for syntax highlighting
#[derive(Debug, Clone)]
pub struct Theme {
    /// Name
    pub name: String,
    /// Styles for token types
    pub styles: HashMap<TokenType, Style>,
    /// Default style
    pub default_style: Style,
}

impl Theme {
    /// Create a new theme
    pub fn new(name: &str) -> Self {
        Self {
            name: name.to_string(),
            styles: HashMap::new(),
            default_style: Style::new(),
        }
    }

    /// Set the default style
    pub fn set_default_style(&mut self, style: Style) {
        self.default_style = style;
    }

    /// Set the style for a token type
    pub fn set_style(&mut self, token_type: TokenType, style: Style) {
        self.styles.insert(token_type, style);
    }

    /// Get the style for a token type
    pub fn get_style(&self, token_type: TokenType) -> Style {
        self.styles.get(&token_type).copied().unwrap_or(self.default_style)
    }
}

/// Syntax registry
#[derive(Debug)]
pub struct SyntaxRegistry {
    /// Syntax definitions
    pub definitions: HashMap<String, SyntaxDefinition>,
}

impl SyntaxRegistry {
    /// Create a new syntax registry
    pub fn new() -> Self {
        Self {
            definitions: HashMap::new(),
        }
    }

    /// Add a syntax definition
    pub fn add_definition(&mut self, definition: SyntaxDefinition) {
        self.definitions.insert(definition.name.clone(), definition);
    }

    /// Get a syntax definition by name
    pub fn get_definition(&self, name: &str) -> Option<&SyntaxDefinition> {
        self.definitions.get(name)
    }

    /// Get a syntax definition for a file
    pub fn get_definition_for_file(&self, path: &Path) -> Option<&SyntaxDefinition> {
        for definition in self.definitions.values() {
            if definition.matches_file(path) {
                return Some(definition);
            }
        }

        None
    }

    /// Get a syntax definition for the first line of a file
    pub fn get_definition_for_first_line(&self, line: &str) -> Option<&SyntaxDefinition> {
        for definition in self.definitions.values() {
            if definition.matches_first_line(line) {
                return Some(definition);
            }
        }

        None
    }
}

/// Syntax highlighter
#[derive(Debug)]
pub struct SyntaxHighlighter {
    /// Syntax registry
    pub registry: Arc<SyntaxRegistry>,
    /// Theme
    pub theme: Arc<Theme>,
}

impl SyntaxHighlighter {
    /// Create a new syntax highlighter
    pub fn new(registry: Arc<SyntaxRegistry>, theme: Arc<Theme>) -> Self {
        Self {
            registry,
            theme,
        }
    }

    /// Highlight a buffer
    pub fn highlight_buffer(&self, buffer: &Buffer) -> Option<Vec<Vec<Token>>> {
        let path = buffer.get_path()?;
        let definition = self.registry.get_definition_for_file(&path)?;
        Some(definition.highlight_buffer(buffer))
    }

    /// Get the style for a token
    pub fn get_style(&self, token: &Token) -> Style {
        self.theme.get_style(token.token_type)
    }
}

/// Create a default syntax registry
pub fn create_default_registry() -> io::Result<SyntaxRegistry> {
    let mut registry = SyntaxRegistry::new();
    
    // Add built-in syntax definitions
    registry.add_definition(create_rust_syntax());
    registry.add_definition(create_c_syntax());
    registry.add_definition(create_python_syntax());
    registry.add_definition(create_javascript_syntax());
    registry.add_definition(create_html_syntax());
    registry.add_definition(create_css_syntax());
    registry.add_definition(create_markdown_syntax());
    registry.add_definition(create_typescript_syntax());
    
    Ok(registry)
}

/// Create a default theme
pub fn create_default_theme() -> Theme {
    let mut theme = Theme::new("default");
    
    // Set default style
    theme.set_default_style(Style::new().foreground("#DCDCDC"));
    
    // Set styles for token types
    theme.set_style(TokenType::Keyword, Style::new().foreground("#569CD6"));
    theme.set_style(TokenType::Identifier, Style::new().foreground("#DCDCDC"));
    theme.set_style(TokenType::String, Style::new().foreground("#CE9178"));
    theme.set_style(TokenType::Character, Style::new().foreground("#CE9178"));
    theme.set_style(TokenType::Number, Style::new().foreground("#B5CEA8"));
    theme.set_style(TokenType::Comment, Style::new().foreground("#6A9955").italic(true));
    theme.set_style(TokenType::Preprocessor, Style::new().foreground("#C586C0"));
    theme.set_style(TokenType::Operator, Style::new().foreground("#DCDCDC"));
    theme.set_style(TokenType::Type, Style::new().foreground("#4EC9B0"));
    theme.set_style(TokenType::Function, Style::new().foreground("#DCDCAA"));
    theme.set_style(TokenType::Variable, Style::new().foreground("#9CDCFE"));
    theme.set_style(TokenType::Constant, Style::new().foreground("#B5CEA8"));
    theme.set_style(TokenType::Special, Style::new().foreground("#DCDCAA"));
    theme.set_style(TokenType::Error, Style::new().foreground("#FF0000").underline(true));
    theme.set_style(TokenType::Todo, Style::new().foreground("#FFFF00").background("#0000FF"));
    
    theme
}

/// Initialize built-in syntax definitions
pub fn init_built_in_syntax() {
    add_syntax_definition(create_rust_syntax());
    add_syntax_definition(create_c_syntax());
    add_syntax_definition(create_python_syntax());
    add_syntax_definition(create_javascript_syntax());
    add_syntax_definition(create_html_syntax());
    add_syntax_definition(create_css_syntax());
    add_syntax_definition(create_markdown_syntax());
    add_syntax_definition(create_typescript_syntax());
}