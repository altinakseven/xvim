//! Vim script execution module
//!
//! This module provides functionality for executing Vim script files and commands.

use std::collections::HashMap;
use std::io::Read;
use std::fs::File;
use std::io::Read;
use std::path::PathBuf;
use std::io::Read;
use std::fs::File;
use std::io::Read;
use std::path::Path;
use std::io::Read;
use std::fs::File;
use std::io::Read;
use std::path::PathBuf;
use std::io::Read;
use std::fs::File;
use std::io::Read;
use std::sync::Mutex;
use std::io::Read;
use std::fs::File;
use std::io::Read;
use std::path::PathBuf;
use std::io::Read;
use std::fs::File;
use std::io::Read;
use std::path::Path;
use std::io::Read;
use std::fs::File;
use std::io::Read;
use std::path::PathBuf;
use std::io::Read;
use std::fs::File;
use std::io::Read;
use std::sync::Arc;
use std::io::Read;
use std::fs::File;
use std::io::Read;
use std::path::PathBuf;
use std::io::Read;
use std::fs::File;
use std::io::Read;
use std::path::Path;
use std::io::Read;
use std::fs::File;
use std::io::Read;
use std::path::PathBuf;
use std::io::Read;
use std::fs::File;
use std::io::Read;
use std::sync::Mutex;
use std::io::Read;
use std::fs::File;
use std::io::Read;
use std::path::PathBuf;
use std::io::Read;
use std::fs::File;
use std::io::Read;
use std::path::Path;
use std::io::Read;
use std::fs::File;
use std::io::Read;
use std::path::PathBuf;
use std::io::Read;
use std::fs::File;
use std::io::Read;
use std::fs::{self, File};
use std::io::Read;
use std::fs::File;
use std::io::Read;
use std::path::PathBuf;
use std::io::Read;
use std::fs::File;
use std::io::Read;
use std::path::Path;
use std::io::Read;
use std::fs::File;
use std::io::Read;
use std::path::PathBuf;
use std::io::Read;
use std::fs::File;
use std::io::Read;
use std::sync::Mutex;
use std::io::Read;
use std::fs::File;
use std::io::Read;
use std::path::PathBuf;
use std::io::Read;
use std::fs::File;
use std::io::Read;
use std::path::Path;
use std::io::Read;
use std::fs::File;
use std::io::Read;
use std::path::PathBuf;
use std::io::Read;
use std::fs::File;
use std::io::Read;
use std::sync::Arc;
use std::io::Read;
use std::fs::File;
use std::io::Read;
use std::path::PathBuf;
use std::io::Read;
use std::fs::File;
use std::io::Read;
use std::path::Path;
use std::io::Read;
use std::fs::File;
use std::io::Read;
use std::path::PathBuf;
use std::io::Read;
use std::fs::File;
use std::io::Read;
use std::sync::Mutex;
use std::io::Read;
use std::fs::File;
use std::io::Read;
use std::path::PathBuf;
use std::io::Read;
use std::fs::File;
use std::io::Read;
use std::path::Path;
use std::io::Read;
use std::fs::File;
use std::io::Read;
use std::path::PathBuf;
use std::io::Read;
use std::fs::File;
use std::io::Read;
use std::io::{self, Read};
use std::io::Read;
use std::fs::File;
use std::io::Read;
use std::path::PathBuf;
use std::io::Read;
use std::fs::File;
use std::io::Read;
use std::path::Path;
use std::io::Read;
use std::fs::File;
use std::io::Read;
use std::path::PathBuf;
use std::io::Read;
use std::fs::File;
use std::io::Read;
use std::sync::Mutex;
use std::io::Read;
use std::fs::File;
use std::io::Read;
use std::path::PathBuf;
use std::io::Read;
use std::fs::File;
use std::io::Read;
use std::path::Path;
use std::io::Read;
use std::fs::File;
use std::io::Read;
use std::path::PathBuf;
use std::io::Read;
use std::fs::File;
use std::io::Read;
use std::sync::Arc;
use std::io::Read;
use std::fs::File;
use std::io::Read;
use std::path::PathBuf;
use std::io::Read;
use std::fs::File;
use std::io::Read;
use std::path::Path;
use std::io::Read;
use std::fs::File;
use std::io::Read;
use std::path::PathBuf;
use std::io::Read;
use std::fs::File;
use std::io::Read;
use std::sync::Mutex;
use std::io::Read;
use std::fs::File;
use std::io::Read;
use std::path::PathBuf;
use std::io::Read;
use std::fs::File;
use std::io::Read;
use std::path::Path;
use std::io::Read;
use std::fs::File;
use std::io::Read;
use std::path::PathBuf;
use std::io::Read;
use std::fs::File;
use std::io::Read;
use std::path::{Path, PathBuf};
use std::io::Read;
use std::fs::File;
use std::io::Read;
use std::path::PathBuf;
use std::io::Read;
use std::fs::File;
use std::io::Read;
use std::path::Path;
use std::io::Read;
use std::fs::File;
use std::io::Read;
use std::path::PathBuf;
use std::io::Read;
use std::fs::File;
use std::io::Read;
use std::sync::Mutex;
use std::io::Read;
use std::fs::File;
use std::io::Read;
use std::path::PathBuf;
use std::io::Read;
use std::fs::File;
use std::io::Read;
use std::path::Path;
use std::io::Read;
use std::fs::File;
use std::io::Read;
use std::path::PathBuf;
use std::io::Read;
use std::fs::File;
use std::io::Read;
use std::sync::Arc;
use std::io::Read;
use std::fs::File;
use std::io::Read;
use std::path::PathBuf;
use std::io::Read;
use std::fs::File;
use std::io::Read;
use std::path::Path;
use std::io::Read;
use std::fs::File;
use std::io::Read;
use std::path::PathBuf;
use std::io::Read;
use std::fs::File;
use std::io::Read;
use std::sync::Mutex;
use std::io::Read;
use std::fs::File;
use std::io::Read;
use std::path::PathBuf;
use std::io::Read;
use std::fs::File;
use std::io::Read;
use std::path::Path;
use std::io::Read;
use std::fs::File;
use std::io::Read;
use std::path::PathBuf;
use std::io::Read;
use std::fs::File;
use std::io::Read;
use std::sync::{Arc, Mutex};
use std::io::Read;
use std::fs::File;
use std::io::Read;
use std::path::PathBuf;
use std::io::Read;
use std::fs::File;
use std::io::Read;
use std::path::Path;
use std::io::Read;
use std::fs::File;
use std::io::Read;
use std::path::PathBuf;
use std::io::Read;
use std::fs::File;
use std::io::Read;
use std::sync::Mutex;
use std::io::Read;
use std::fs::File;
use std::io::Read;
use std::path::PathBuf;
use std::io::Read;
use std::fs::File;
use std::io::Read;
use std::path::Path;
use std::io::Read;
use std::fs::File;
use std::io::Read;
use std::path::PathBuf;
use std::io::Read;
use std::fs::File;
use std::io::Read;
use std::sync::Arc;
use std::io::Read;
use std::fs::File;
use std::io::Read;
use std::path::PathBuf;
use std::io::Read;
use std::fs::File;
use std::io::Read;
use std::path::Path;
use std::io::Read;
use std::fs::File;
use std::io::Read;
use std::path::PathBuf;
use std::io::Read;
use std::fs::File;
use std::io::Read;
use std::sync::Mutex;
use std::io::Read;
use std::fs::File;
use std::io::Read;
use std::path::PathBuf;
use std::io::Read;
use std::fs::File;
use std::io::Read;
use std::path::Path;
use std::io::Read;
use std::fs::File;
use std::io::Read;
use std::path::PathBuf;
use std::io::Read;
use std::fs::File;
use std::io::Read;

use crate::command::ExCommandRegistry;
use std::io::Read;
use std::fs::File;
use std::io::Read;
use std::path::PathBuf;
use std::io::Read;
use std::fs::File;
use std::io::Read;
use std::path::Path;
use std::io::Read;
use std::fs::File;
use std::io::Read;
use std::path::PathBuf;
use std::io::Read;
use std::fs::File;
use std::io::Read;
use std::sync::Mutex;
use std::io::Read;
use std::fs::File;
use std::io::Read;
use std::path::PathBuf;
use std::io::Read;
use std::fs::File;
use std::io::Read;
use std::path::Path;
use std::io::Read;
use std::fs::File;
use std::io::Read;
use std::path::PathBuf;
use std::io::Read;
use std::fs::File;
use std::io::Read;
use std::sync::Arc;
use std::io::Read;
use std::fs::File;
use std::io::Read;
use std::path::PathBuf;
use std::io::Read;
use std::fs::File;
use std::io::Read;
use std::path::Path;
use std::io::Read;
use std::fs::File;
use std::io::Read;
use std::path::PathBuf;
use std::io::Read;
use std::fs::File;
use std::io::Read;
use std::sync::Mutex;
use std::io::Read;
use std::fs::File;
use std::io::Read;
use std::path::PathBuf;
use std::io::Read;
use std::fs::File;
use std::io::Read;
use std::path::Path;
use std::io::Read;
use std::fs::File;
use std::io::Read;
use std::path::PathBuf;
use std::io::Read;
use std::fs::File;
use std::io::Read;
use crate::editor::Editor;
use std::io::Read;
use std::fs::File;
use std::io::Read;
use std::path::PathBuf;
use std::io::Read;
use std::fs::File;
use std::io::Read;
use std::path::Path;
use std::io::Read;
use std::fs::File;
use std::io::Read;
use std::path::PathBuf;
use std::io::Read;
use std::fs::File;
use std::io::Read;
use std::sync::Mutex;
use std::io::Read;
use std::fs::File;
use std::io::Read;
use std::path::PathBuf;
use std::io::Read;
use std::fs::File;
use std::io::Read;
use std::path::Path;
use std::io::Read;
use std::fs::File;
use std::io::Read;
use std::path::PathBuf;
use std::io::Read;
use std::fs::File;
use std::io::Read;
use std::sync::Arc;
use std::io::Read;
use std::fs::File;
use std::io::Read;
use std::path::PathBuf;
use std::io::Read;
use std::fs::File;
use std::io::Read;
use std::path::Path;
use std::io::Read;
use std::fs::File;
use std::io::Read;
use std::path::PathBuf;
use std::io::Read;
use std::fs::File;
use std::io::Read;
use std::sync::Mutex;
use std::io::Read;
use std::fs::File;
use std::io::Read;
use std::path::PathBuf;
use std::io::Read;
use std::fs::File;
use std::io::Read;
use std::path::Path;
use std::io::Read;
use std::fs::File;
use std::io::Read;
use std::path::PathBuf;
use std::io::Read;
use std::fs::File;
use std::io::Read;

// Global state for the Vim script interpreter
static mut VIM_SCRIPT_INTERPRETER: Option<VimScriptInterpreter> = None;
static mut EDITOR: Option<*mut Editor> = None;
static mut RUNTIME_DIR: Option<PathBuf> = None;

/// Initialize the Vim script interpreter
pub fn init_vim_script_interpreter(registry: Arc<Mutex<ExCommandRegistry>>) {
    unsafe {
        VIM_SCRIPT_INTERPRETER = Some(VimScriptInterpreter::new(registry));
    }
}

/// Set the editor reference
pub fn set_editor(editor: *mut Editor) {
    unsafe {
        EDITOR = Some(editor);
    }
}

/// Set the runtime directory
pub fn set_runtime_dir(dir: &Path) {
    unsafe {
        RUNTIME_DIR = Some(dir.to_path_buf());
    }
}

/// Get the runtime directory
pub fn get_runtime_dir() -> Option<PathBuf> {
    unsafe {
        RUNTIME_DIR.clone()
    }
}

/// Execute a Vim script file
pub fn execute_file(path: &Path) -> io::Result<()> {
    // Read the file
    let content = fs::read_to_string(path)?;
    
    // Execute the script
    unsafe {
        if let Some(ref mut interpreter) = VIM_SCRIPT_INTERPRETER {
            interpreter.execute_file(path, &content)?;
        }
    }
    
    Ok(())
}

/// Execute a Vim script command
pub fn execute(command: &str) -> io::Result<()> {
    unsafe {
        if let Some(ref mut interpreter) = VIM_SCRIPT_INTERPRETER {
            interpreter.execute(command)?;
        }
    }
    
    Ok(())
}

/// Execute a single line of Vim script
pub fn execute_line(line: &str) -> io::Result<()> {
    unsafe {
        if let Some(ref mut interpreter) = VIM_SCRIPT_INTERPRETER {
            interpreter.execute_line(line)?;
        }
    }
    
    Ok(())
}

/// Register Vim script commands with the command registry
pub fn register_vim_script_commands(registry: &mut ExCommandRegistry) {
    // Register source command
    registry.register("source", |cmd| {
        if cmd.args.is_empty() {
            return Err(crate::command::ExCommandError::MissingArgument("source".to_string()));
        }
        
        let path = Path::new(&cmd.args);
        execute_file(path)?;
        
        Ok(())
    });
    
    // Register runtime command
    registry.register("runtime", |cmd| {
        if cmd.args.is_empty() {
            return Err(crate::command::ExCommandError::MissingArgument("runtime".to_string()));
        }
        
        let runtime_dir = get_runtime_dir();
        if let Some(dir) = runtime_dir {
            let path = dir.join(&cmd.args);
            if path.exists() {
                execute_file(&path)?;
            } else {
                return Err(crate::command::ExCommandError::FileNotFound(path.to_string_lossy().to_string()));
            }
        } else {
            return Err(crate::command::ExCommandError::Other("Runtime directory not set".to_string()));
        }
        
        Ok(())
    });
    
    // Register scriptnames command
    registry.register("scriptnames", |_| {
        unsafe {
            if let Some(ref interpreter) = VIM_SCRIPT_INTERPRETER {
                for (i, path) in interpreter.script_names.iter().enumerate() {
                    println!("{}: {}", i + 1, path.display());
                }
            }
        }
        
        Ok(())
    });
    
    // Register let command
    registry.register("let", |cmd| {
        if cmd.args.is_empty() {
            return Err(crate::command::ExCommandError::MissingArgument("let".to_string()));
        }
        
        execute_line(&format!("let {}", cmd.args))?;
        
        Ok(())
    });
    
    // Register unlet command
    registry.register("unlet", |cmd| {
        if cmd.args.is_empty() {
            return Err(crate::command::ExCommandError::MissingArgument("unlet".to_string()));
        }
        
        execute_line(&format!("unlet {}", cmd.args))?;
        
        Ok(())
    });
    
    // Register echo command
    registry.register("echo", |cmd| {
        execute_line(&format!("echo {}", cmd.args))?;
        
        Ok(())
    });
    
    // Register echom command
    registry.register("echom", |cmd| {
        execute_line(&format!("echom {}", cmd.args))?;
        
        Ok(())
    });
    
    // Register echon command
    registry.register("echon", |cmd| {
        execute_line(&format!("echon {}", cmd.args))?;
        
        Ok(())
    });
    
    // Register execute command
    registry.register("execute", |cmd| {
        if cmd.args.is_empty() {
            return Err(crate::command::ExCommandError::MissingArgument("execute".to_string()));
        }
        
        execute_line(&format!("execute {}", cmd.args))?;
        
        Ok(())
    });
    
    // Register call command
    registry.register("call", |cmd| {
        if cmd.args.is_empty() {
            return Err(crate::command::ExCommandError::MissingArgument("call".to_string()));
        }
        
        execute_line(&format!("call {}", cmd.args))?;
        
        Ok(())
    });
    
    // Register if command
    registry.register("if", |cmd| {
        if cmd.args.is_empty() {
            return Err(crate::command::ExCommandError::MissingArgument("if".to_string()));
        }
        
        execute_line(&format!("if {}", cmd.args))?;
        
        Ok(())
    });
    
    // Register else command
    registry.register("else", |_| {
        execute_line("else")?;
        
        Ok(())
    });
    
    // Register elseif command
    registry.register("elseif", |cmd| {
        if cmd.args.is_empty() {
            return Err(crate::command::ExCommandError::MissingArgument("elseif".to_string()));
        }
        
        execute_line(&format!("elseif {}", cmd.args))?;
        
        Ok(())
    });
    
    // Register endif command
    registry.register("endif", |_| {
        execute_line("endif")?;
        
        Ok(())
    });
    
    // Register while command
    registry.register("while", |cmd| {
        if cmd.args.is_empty() {
            return Err(crate::command::ExCommandError::MissingArgument("while".to_string()));
        }
        
        execute_line(&format!("while {}", cmd.args))?;
        
        Ok(())
    });
    
    // Register endwhile command
    registry.register("endwhile", |_| {
        execute_line("endwhile")?;
        
        Ok(())
    });
    
    // Register for command
    registry.register("for", |cmd| {
        if cmd.args.is_empty() {
            return Err(crate::command::ExCommandError::MissingArgument("for".to_string()));
        }
        
        execute_line(&format!("for {}", cmd.args))?;
        
        Ok(())
    });
    
    // Register endfor command
    registry.register("endfor", |_| {
        execute_line("endfor")?;
        
        Ok(())
    });
    
    // Register function command
    registry.register("function", |cmd| {
        if cmd.args.is_empty() {
            return Err(crate::command::ExCommandError::MissingArgument("function".to_string()));
        }
        
        execute_line(&format!("function {}", cmd.args))?;
        
        Ok(())
    });
    
    // Register endfunction command
    registry.register("endfunction", |_| {
        execute_line("endfunction")?;
        
        Ok(())
    });
    
    // Register return command
    registry.register("return", |cmd| {
        execute_line(&format!("return {}", cmd.args))?;
        
        Ok(())
    });
    
    // Register delfunction command
    registry.register("delfunction", |cmd| {
        if cmd.args.is_empty() {
            return Err(crate::command::ExCommandError::MissingArgument("delfunction".to_string()));
        }
        
        execute_line(&format!("delfunction {}", cmd.args))?;
        
        Ok(())
    });
    
    // Register silent command
    registry.register("silent", |cmd| {
        execute_line(&format!("silent {}", cmd.args))?;
        
        Ok(())
    });
}

/// Vim script value
#[derive(Clone, Debug)]
pub enum VimValue {
    /// String value
    String(String),
    /// Integer value
    Integer(i64),
    /// Float value
    Float(f64),
    /// List value
    List(Vec<VimValue>),
    /// Dictionary value
    Dict(HashMap<String, VimValue>),
    /// Boolean value
    Boolean(bool),
    /// Null value
    Null,
}

impl VimValue {
    /// Convert to string
    pub fn to_string(&self) -> String {
        match self {
            VimValue::String(s) => s.clone(),
            VimValue::Integer(i) => i.to_string(),
            VimValue::Float(f) => f.to_string(),
            VimValue::List(l) => {
                let items: Vec<String> = l.iter().map(|v| v.to_string()).collect();
                format!("[{}]", items.join(", "))
            },
            VimValue::Dict(d) => {
                let items: Vec<String> = d.iter().map(|(k, v)| format!("'{}': {}", k, v.to_string())).collect();
                format!("{{{}}}", items.join(", "))
            },
            VimValue::Boolean(b) => if *b { "1".to_string() } else { "0".to_string() },
            VimValue::Null => "".to_string(),
        }
    }
    
    /// Convert to integer
    pub fn to_integer(&self) -> i64 {
        match self {
            VimValue::String(s) => s.parse::<i64>().unwrap_or(0),
            VimValue::Integer(i) => *i,
            VimValue::Float(f) => *f as i64,
            VimValue::Boolean(b) => if *b { 1 } else { 0 },
            _ => 0,
        }
    }
    
    /// Convert to float
    pub fn to_float(&self) -> f64 {
        match self {
            VimValue::String(s) => s.parse::<f64>().unwrap_or(0.0),
            VimValue::Integer(i) => *i as f64,
            VimValue::Float(f) => *f,
            VimValue::Boolean(b) => if *b { 1.0 } else { 0.0 },
            _ => 0.0,
        }
    }
    
    /// Convert to boolean
    pub fn to_boolean(&self) -> bool {
        match self {
            VimValue::String(s) => !s.is_empty(),
            VimValue::Integer(i) => *i != 0,
            VimValue::Float(f) => *f != 0.0,
            VimValue::List(l) => !l.is_empty(),
            VimValue::Dict(d) => !d.is_empty(),
            VimValue::Boolean(b) => *b,
            VimValue::Null => false,
        }
    }
}

/// Vim script scope
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub enum VimScope {
    /// Global scope (g:)
    Global,
    /// Buffer scope (b:)
    Buffer,
    /// Window scope (w:)
    Window,
    /// Tab scope (t:)
    Tab,
    /// Script scope (s:)
    Script,
    /// Function scope (l:)
    Function,
    /// Argument scope (a:)
    Argument,
    /// Vim scope (v:)
    Vim,
    /// Environment scope (env:)
    Environment,
    /// Option scope (&)
    Option,
    /// Register scope (@)
    Register,
    /// No scope
    None,
}

impl VimScope {
    /// Parse a scope from a string
    pub fn parse(s: &str) -> Option<VimScope> {
        match s {
            "g:" => Some(VimScope::Global),
            "b:" => Some(VimScope::Buffer),
            "w:" => Some(VimScope::Window),
            "t:" => Some(VimScope::Tab),
            "s:" => Some(VimScope::Script),
            "l:" => Some(VimScope::Function),
            "a:" => Some(VimScope::Argument),
            "v:" => Some(VimScope::Vim),
            "env:" => Some(VimScope::Environment),
            "&" => Some(VimScope::Option),
            "@" => Some(VimScope::Register),
            _ => None,
        }
    }
    
    /// Get the scope prefix
    pub fn prefix(&self) -> &'static str {
        match self {
            VimScope::Global => "g:",
            VimScope::Buffer => "b:",
            VimScope::Window => "w:",
            VimScope::Tab => "t:",
            VimScope::Script => "s:",
            VimScope::Function => "l:",
            VimScope::Argument => "a:",
            VimScope::Vim => "v:",
            VimScope::Environment => "env:",
            VimScope::Option => "&",
            VimScope::Register => "@",
            VimScope::None => "",
        }
    }
}

/// Vim script variable
#[derive(Clone, Debug)]
pub struct VimVariable {
    /// Variable name
    pub name: String,
    /// Variable scope
    pub scope: VimScope,
    /// Variable value
    pub value: VimValue,
}

impl VimVariable {
    /// Create a new variable
    pub fn new(name: &str, scope: VimScope, value: VimValue) -> Self {
        Self {
            name: name.to_string(),
            scope,
            value,
        }
    }
    
    /// Get the full name of the variable
    pub fn full_name(&self) -> String {
        format!("{}{}", self.scope.prefix(), self.name)
    }
}

/// Vim script function
#[derive(Clone, Debug)]
pub struct VimFunction {
    /// Function name
    pub name: String,
    /// Function arguments
    pub args: Vec<String>,
    /// Function body
    pub body: Vec<String>,
    /// Is script-local
    pub is_script_local: bool,
    /// Script ID
    pub script_id: Option<usize>,
    /// Line number
    pub line: usize,
}

impl VimFunction {
    /// Create a new function
    pub fn new(name: &str, args: Vec<String>, body: Vec<String>, is_script_local: bool, script_id: Option<usize>, line: usize) -> Self {
        Self {
            name: name.to_string(),
            args,
            body,
            is_script_local,
            script_id,
            line,
        }
    }
    
    /// Get the full name of the function
    pub fn full_name(&self) -> String {
        if self.is_script_local {
            if let Some(script_id) = self.script_id {
                format!("<SNR>{}_{}",script_id, self.name)
            } else {
                format!("s:{}", self.name)
            }
        } else {
            self.name.clone()
        }
    }
}

/// Vim script execution context
#[derive(Debug)]
pub struct VimContext {
    /// Variables by scope
    pub variables: HashMap<VimScope, HashMap<String, VimValue>>,
    /// Functions
    pub functions: HashMap<String, VimFunction>,
    /// Current script
    pub current_script: Option<PathBuf>,
    /// Script ID
    pub script_id: usize,
    /// Script stack
    pub script_stack: Vec<PathBuf>,
    /// Function stack
    pub function_stack: Vec<String>,
    /// Command output
    pub output: String,
    /// Command registry
    pub command_registry: Arc<Mutex<ExCommandRegistry>>,
    /// Editor
    pub editor: Option<*mut Editor>,
}

impl VimContext {
    /// Create a new context
    pub fn new(command_registry: Arc<Mutex<ExCommandRegistry>>) -> Self {
        let mut context = Self {
            variables: HashMap::new(),
            functions: HashMap::new(),
            current_script: None,
            script_id: 0,
            script_stack: Vec::new(),
            function_stack: Vec::new(),
            output: String::new(),
            command_registry,
            editor: None,
        };
        
        // Initialize variable scopes
        context.variables.insert(VimScope::Global, HashMap::new());
        context.variables.insert(VimScope::Buffer, HashMap::new());
        context.variables.insert(VimScope::Window, HashMap::new());
        context.variables.insert(VimScope::Tab, HashMap::new());
        context.variables.insert(VimScope::Script, HashMap::new());
        context.variables.insert(VimScope::Function, HashMap::new());
        context.variables.insert(VimScope::Argument, HashMap::new());
        context.variables.insert(VimScope::Vim, HashMap::new());
        context.variables.insert(VimScope::Environment, HashMap::new());
        context.variables.insert(VimScope::Option, HashMap::new());
        context.variables.insert(VimScope::Register, HashMap::new());
        
        // Initialize Vim variables
        context.set_variable("version", VimScope::Vim, VimValue::Integer(900));
        context.set_variable("count", VimScope::Vim, VimValue::Integer(0));
        context.set_variable("count1", VimScope::Vim, VimValue::Integer(0));
        context.set_variable("prevcount", VimScope::Vim, VimValue::Integer(0));
        context.set_variable("register", VimScope::Vim, VimValue::String("".to_string()));
        context.set_variable("operator", VimScope::Vim, VimValue::String("".to_string()));
        context.set_variable("shell_error", VimScope::Vim, VimValue::Integer(0));
        context.set_variable("this_session", VimScope::Vim, VimValue::String("".to_string()));
        context.set_variable("errmsg", VimScope::Vim, VimValue::String("".to_string()));
        context.set_variable("warningmsg", VimScope::Vim, VimValue::String("".to_string()));
        context.set_variable("statusmsg", VimScope::Vim, VimValue::String("".to_string()));
        context.set_variable("searchforward", VimScope::Vim, VimValue::Integer(1));
        context.set_variable("hlsearch", VimScope::Vim, VimValue::Integer(1));
        context.set_variable("insertmode", VimScope::Vim, VimValue::String("".to_string()));
        context.set_variable("val", VimScope::Vim, VimValue::Integer(0));
        context.set_variable("key", VimScope::Vim, VimValue::String("".to_string()));
        context.set_variable("char", VimScope::Vim, VimValue::String("".to_string()));
        context.set_variable("mouse_win", VimScope::Vim, VimValue::Integer(0));
        context.set_variable("mouse_lnum", VimScope::Vim, VimValue::Integer(0));
        context.set_variable("mouse_col", VimScope::Vim, VimValue::Integer(0));
        context.set_variable("lnum", VimScope::Vim, VimValue::Integer(0));
        context.set_variable("termresponse", VimScope::Vim, VimValue::String("".to_string()));
        context.set_variable("fname", VimScope::Vim, VimValue::String("".to_string()));
        context.set_variable("data", VimScope::Vim, VimValue::Dict(HashMap::new()));
        context.set_variable("oldfiles", VimScope::Vim, VimValue::List(Vec::new()));
        context.set_variable("argv", VimScope::Vim, VimValue::List(Vec::new()));
        context.set_variable("argidx", VimScope::Vim, VimValue::Integer(0));
        context.set_variable("progname", VimScope::Vim, VimValue::String("xvim".to_string()));
        context.set_variable("servername", VimScope::Vim, VimValue::String("".to_string()));
        context.set_variable("dying", VimScope::Vim, VimValue::Integer(0));
        context.set_variable("exiting", VimScope::Vim, VimValue::Integer(0));
        context.set_variable("termreason", VimScope::Vim, VimValue::String("".to_string()));
        context.set_variable("completed_item", VimScope::Vim, VimValue::Dict(HashMap::new()));
        context.set_variable("option_new", VimScope::Vim, VimValue::String("".to_string()));
        context.set_variable("option_old", VimScope::Vim, VimValue::String("".to_string()));
        context.set_variable("option_type", VimScope::Vim, VimValue::String("".to_string()));
        context.set_variable("errors", VimScope::Vim, VimValue::List(Vec::new()));
        context.set_variable("false", VimScope::Vim, VimValue::Integer(0));
        context.set_variable("true", VimScope::Vim, VimValue::Integer(1));
        context.set_variable("null", VimScope::Vim, VimValue::Null);
        context.set_variable("none", VimScope::Vim, VimValue::Null);
        
        // Set the editor reference
        unsafe {
            context.editor = EDITOR;
        }
        
        context
    }
    
    /// Set a variable
    pub fn set_variable(&mut self, name: &str, scope: VimScope, value: VimValue) {
        if let Some(scope_vars) = self.variables.get_mut(&scope) {
            scope_vars.insert(name.to_string(), value);
        }
    }
    
    /// Get a variable
    pub fn get_variable(&self, name: &str, scope: VimScope) -> Option<VimValue> {
        if let Some(scope_vars) = self.variables.get(&scope) {
            scope_vars.get(name).cloned()
        } else {
            None
        }
    }
    
    /// Set a function
    pub fn set_function(&mut self, function: VimFunction) {
        self.functions.insert(function.name.clone(), function);
    }
    
    /// Get a function
    pub fn get_function(&self, name: &str) -> Option<VimFunction> {
        self.functions.get(name).cloned()
    }
    
    /// Parse a variable name
    pub fn parse_variable_name(&self, name: &str) -> (String, VimScope) {
        if name.starts_with("g:") {
            (name[2..].to_string(), VimScope::Global)
        } else if name.starts_with("b:") {
            (name[2..].to_string(), VimScope::Buffer)
        } else if name.starts_with("w:") {
            (name[2..].to_string(), VimScope::Window)
        } else if name.starts_with("t:") {
            (name[2..].to_string(), VimScope::Tab)
        } else if name.starts_with("s:") {
            (name[2..].to_string(), VimScope::Script)
        } else if name.starts_with("l:") {
            (name[2..].to_string(), VimScope::Function)
        } else if name.starts_with("a:") {
            (name[2..].to_string(), VimScope::Argument)
        } else if name.starts_with("v:") {
            (name[2..].to_string(), VimScope::Vim)
        } else if name.starts_with("env:") {
            (name[4..].to_string(), VimScope::Environment)
        } else if name.starts_with("&") {
            (name[1..].to_string(), VimScope::Option)
        } else if name.starts_with("@") {
            (name[1..].to_string(), VimScope::Register)
        } else {
            (name.to_string(), VimScope::None)
        }
    }
    
    /// Evaluate an expression
    pub fn evaluate_expression(&self, expr: &str) -> io::Result<VimValue> {
        // Simple expression evaluation for now
        // In a real implementation, this would be a full expression parser
        
        // Try to parse as a number
        if let Ok(num) = expr.parse::<i64>() {
            return Ok(VimValue::Integer(num));
        }
        
        // Try to parse as a float
        if let Ok(num) = expr.parse::<f64>() {
            return Ok(VimValue::Float(num));
        }
        
        // Check if it's a string literal
        if expr.starts_with('"') && expr.ends_with('"') {
            return Ok(VimValue::String(expr[1..expr.len()-1].to_string()));
        }
        
        // Check if it's a list literal
        if expr.starts_with('[') && expr.ends_with(']') {
            let mut list = Vec::new();
            let items = expr[1..expr.len()-1].split(',');
            for item in items {
                let item = item.trim();
                if !item.is_empty() {
                    list.push(self.evaluate_expression(item)?);
                }
            }
            return Ok(VimValue::List(list));
        }
        
        // Check if it's a dictionary literal
        if expr.starts_with('{') && expr.ends_with('}') {
            let mut dict = HashMap::new();
            let items = expr[1..expr.len()-1].split(',');
            for item in items {
                let item = item.trim();
                if !item.is_empty() {
                    let parts: Vec<&str> = item.splitn(2, ':').collect();
                    if parts.len() == 2 {
                        let key = parts[0].trim();
                        let value = parts[1].trim();
                        
                        // Parse the key
                        let key = if key.starts_with('"') && key.ends_with('"') {
                            key[1..key.len()-1].to_string()
                        } else if key.starts_with('\'') && key.ends_with('\'') {
                            key[1..key.len()-1].to_string()
                        } else {
                            key.to_string()
                        };
                        
                        // Parse the value
                        let value = self.evaluate_expression(value)?;
                        
                        dict.insert(key, value);
                    }
                }
            }
            return Ok(VimValue::Dict(dict));
        }
        
        // Check if it's a variable
        let (name, scope) = self.parse_variable_name(expr);
        if let Some(value) = self.get_variable(&name, scope) {
            return Ok(value);
        }
        
        // Default to empty string
        Ok(VimValue::String("".to_string()))
    }
}

/// Vim script interpreter
#[derive(Debug)]
pub struct VimScriptInterpreter {
    /// Execution context
    pub context: VimContext,
    /// Runtime directory
    pub runtime_dir: Option<PathBuf>,
    /// Script names
    pub script_names: Vec<PathBuf>,
    /// Next script ID
    pub next_script_id: usize,
}

impl VimScriptInterpreter {
    /// Create a new interpreter
    pub fn new(command_registry: Arc<Mutex<ExCommandRegistry>>) -> Self {
        Self {
            context: VimContext::new(command_registry),
            runtime_dir: None,
            script_names: Vec::new(),
            next_script_id: 1,
        }
    }
    
    /// Execute a Vim script file
    pub fn execute_file(&mut self, path: &Path, content: &str) -> io::Result<()> {
        // Save the current script
        let old_script = self.context.current_script.clone();
        let old_script_id = self.context.script_id;
        
        // Set the new script
        self.context.current_script = Some(path.to_path_buf());
        self.context.script_id = self.next_script_id;
        self.next_script_id += 1;
        
        // Add the script to the script stack
        self.context.script_stack.push(path.to_path_buf());
        
        // Add the script to the script names
        self.script_names.push(path.to_path_buf());
        
        // Execute the script
        let result = self.execute(content);
        
        // Restore the old script
        self.context.current_script = old_script;
        self.context.script_id = old_script_id;
        
        // Remove the script from the script stack
        self.context.script_stack.pop();
        
        result
    }
    
    /// Execute a Vim script
    pub fn execute(&mut self, script: &str) -> io::Result<()> {
        // Split the script into lines
        let lines = script.lines();
        
        // Execute each line
        for line in lines {
            self.execute_line(line)?;
        }
        
        Ok(())
    }
    
    /// Execute a single line of Vim script
    pub fn execute_line(&mut self, line: &str) -> io::Result<()> {
        // Trim the line
        let line = line.trim();
        
        // Skip empty lines and comments
        if line.is_empty() || line.starts_with('"') {
            return Ok(());
        }
        
        // Handle let command
        if line.starts_with("let ") {
            return self.execute_let(line);
        }
        
        // Handle unlet command
        if line.starts_with("unlet ") {
            return self.execute_unlet(line);
        }
        
        // Handle echo command
        if line.starts_with("echo ") {
            return self.execute_echo(line);
        }
        
        // Handle echom command
        if line.starts_with("echom ") {
            return self.execute_echom(line);
        }
        
        // Handle echon command
        if line.starts_with("echon ") {
            return self.execute_echon(line);
        }
        
        // Handle execute command
        if line.starts_with("execute ") {
            return self.execute_execute(line);
        }
        
        // Handle call command
        if line.starts_with("call ") {
            return self.execute_call(line);
        }
        
        // Handle if command
        if line.starts_with("if ") {
            return self.execute_if(line);
        }
        
        // Handle else command
        if line == "else" {
            return self.execute_else();
        }
        
        // Handle elseif command
        if line.starts_with("elseif ") {
            return self.execute_elseif(line);
        }
        
        // Handle endif command
        if line == "endif" {
            return self.execute_endif();
        }
        
        // Handle while command
        if line.starts_with("while ") {
            return self.execute_while(line);
        }
        
        // Handle endwhile command
        if line == "endwhile" {
            return self.execute_endwhile();
        }
        
        // Handle for command
        if line.starts_with("for ") {
            return self.execute_for(line);
        }
        
        // Handle endfor command
        if line == "endfor" {
            return self.execute_endfor();
        }
        
        // Handle function command
        if line.starts_with("function") || line.starts_with("function!") {
            return self.execute_function(line);
        }
        
        // Handle endfunction command
        if line == "endfunction" {
            return self.execute_endfunction();
        }
        
        // Handle return command
        if line.starts_with("return") {
            return self.execute_return(line);
        }
        
        // Handle delfunction command
        if line.starts_with("delfunction ") {
            return self.execute_delfunction(line);
        }
        
        // Handle silent command
        if line.starts_with("silent ") {
            return self.execute_silent(line);
        }
        
        // Handle set command
        if line.starts_with("set ") {
            return self.execute_set(line);
        }
        
        // Handle other commands
        self.execute_command(line)
    }
    
    /// Execute a let command
    fn execute_let(&mut self, line: &str) -> io::Result<()> {
        // Parse the let command
        let parts: Vec<&str> = line[4..].splitn(2, '=').collect();
        if parts.len() != 2 {
            return Err(io::Error::new(io::ErrorKind::InvalidInput, "Invalid let command"));
        }
        
        let var_name = parts[0].trim();
        let expr = parts[1].trim();
        
        // Evaluate the expression
        let value = self.context.evaluate_expression(expr)?;
        
        // Parse the variable name
        let (name, scope) = self.context.parse_variable_name(var_name);
        
        // Set the variable
        self.context.set_variable(&name, scope, value);
        
        Ok(())
    }
    
    /// Execute an unlet command
    fn execute_unlet(&mut self, line: &str) -> io::Result<()> {
        // Parse the unlet command
        let var_name = line[6..].trim();
        
        // Parse the variable name
        let (name, scope) = self.context.parse_variable_name(var_name);
        
        // Remove the variable
        if let Some(scope_vars) = self.context.variables.get_mut(&scope) {
            scope_vars.remove(&name);
        }
        
        Ok(())
    }
    
    /// Execute an echo command
    fn execute_echo(&mut self, line: &str) -> io::Result<()> {
        // Parse the echo command
        let expr = line[5..].trim();
        
        // Evaluate the expression
        let value = self.context.evaluate_expression(expr)?;
        
        // Print the value
        println!("{}", value.to_string());
        
        Ok(())
    }
    
    /// Execute an echom command
    fn execute_echom(&mut self, line: &str) -> io::Result<()> {
        // Parse the echom command
        let expr = line[6..].trim();
        
        // Evaluate the expression
        let value = self.context.evaluate_expression(expr)?;
        
        // Print the value
        println!("{}", value.to_string());
        
        Ok(())
    }
    
    /// Execute an echon command
    fn execute_echon(&mut self, line: &str) -> io::Result<()> {
        // Parse the echon command
        let expr = line[6..].trim();
        
        // Evaluate the expression
        let value = self.context.evaluate_expression(expr)?;
        
        // Print the value without a newline
        print!("{}", value.to_string());
        
        Ok(())
    }
    
    /// Execute an execute command
    fn execute_execute(&mut self, line: &str) -> io::Result<()> {
        // Parse the execute command
        let expr = line[8..].trim();
        
        // Evaluate the expression
        let value = self.context.evaluate_expression(expr)?;
        
        // Execute the command
        self.execute_command(&value.to_string())
    }
    
    /// Execute a call command
    fn execute_call(&mut self, line: &str) -> io::Result<()> {
        // Parse the call command
        let expr = line[5..].trim();
        
        // Parse the function name and arguments
        let mut parts = expr.splitn(2, '(');
        if parts.clone().count() < 2 {
            return Err(io::Error::new(io::ErrorKind::InvalidInput, "Invalid function call"));
        }
        
        let func_name = parts.next().unwrap().trim();
        let args_str = parts.next().unwrap().trim();
        
        // Remove the trailing ')'
        let args_str = if args_str.ends_with(')') {
            &args_str[..args_str.len() - 1]
        } else {
            return Err(io::Error::new(io::ErrorKind::InvalidInput, "Invalid function call"));
        };
        
        // Parse the arguments
        let mut args = Vec::new();
        if !args_str.is_empty() {
            for arg in args_str.split(',') {
                let arg = arg.trim();
                args.push(self.context.evaluate_expression(arg)?);
            }
        }
        
        // Get the function
        if let Some(function) = self.context.get_function(func_name) {
            // Create a new scope for the function
            let old_function_vars = self.context.variables.get(&VimScope::Function).cloned();
            let old_argument_vars = self.context.variables.get(&VimScope::Argument).cloned();
            
            // Set up the function scope
            let mut function_vars = HashMap::new();
            self.context.variables.insert(VimScope::Function, function_vars);
            
            // Set up the argument scope
            let mut argument_vars = HashMap::new();
            for (i, arg) in args.iter().enumerate() {
                if i < function.args.len() {
                    argument_vars.insert(function.args[i].clone(), arg.clone());
                }
            }
            self.context.variables.insert(VimScope::Argument, argument_vars);
            
            // Add the function to the function stack
            self.context.function_stack.push(function.name.clone());
            
            // Execute the function body
            for line in &function.body {
                self.execute_line(line)?;
            }
            
            // Remove the function from the function stack
            self.context.function_stack.pop();
            
            // Restore the old function and argument scopes
            if let Some(vars) = old_function_vars {
                self.context.variables.insert(VimScope::Function, vars);
            } else {
                self.context.variables.remove(&VimScope::Function);
            }
            
            if let Some(vars) = old_argument_vars {
                self.context.variables.insert(VimScope::Argument, vars);
            } else {
                self.context.variables.remove(&VimScope::Argument);
            }
        } else {
            return Err(io::Error::new(io::ErrorKind::NotFound, format!("Function not found: {}", func_name)));
        }
        
        Ok(())
    }
    
    /// Execute an if command
    fn execute_if(&mut self, line: &str) -> io::Result<()> {
        // Parse the if command
        let expr = line[3..].trim();
        
        // Evaluate the expression
        let value = self.context.evaluate_expression(expr)?;
        
        // Check if the condition is true
        if value.to_boolean() {
            // Set a flag to indicate that we're in an if block
            self.context.set_variable("if_active", VimScope::Vim, VimValue::Boolean(true));
            self.context.set_variable("if_condition", VimScope::Vim, VimValue::Boolean(true));
        } else {
            // Set a flag to indicate that we're in an if block but the condition is false
            self.context.set_variable("if_active", VimScope::Vim, VimValue::Boolean(true));
            self.context.set_variable("if_condition", VimScope::Vim, VimValue::Boolean(false));
        }
        
        Ok(())
    }
    
    /// Execute an else command
    fn execute_else(&mut self) -> io::Result<()> {
        // Check if we're in an if block
        if let Some(if_active) = self.context.get_variable("if_active", VimScope::Vim) {
            if if_active.to_boolean() {
                // Get the current condition
                if let Some(if_condition) = self.context.get_variable("if_condition", VimScope::Vim) {
                    // Invert the condition
                    self.context.set_variable("if_condition", VimScope::Vim, VimValue::Boolean(!if_condition.to_boolean()));
                }
            } else {
                return Err(io::Error::new(io::ErrorKind::InvalidInput, "else without if"));
            }
        } else {
            return Err(io::Error::new(io::ErrorKind::InvalidInput, "else without if"));
        }
        
        Ok(())
    }
    
    /// Execute an elseif command
    fn execute_elseif(&mut self, line: &str) -> io::Result<()> {
        // Parse the elseif command
        let expr = line[7..].trim();
        
        // Check if we're in an if block
        if let Some(if_active) = self.context.get_variable("if_active", VimScope::Vim) {
            if if_active.to_boolean() {
                // Get the current condition
                if let Some(if_condition) = self.context.get_variable("if_condition", VimScope::Vim) {
                    // If the current condition is true, set the new condition to false
                    if if_condition.to_boolean() {
                        self.context.set_variable("if_condition", VimScope::Vim, VimValue::Boolean(false));
                    } else {
                        // Otherwise, evaluate the new condition
                        let value = self.context.evaluate_expression(expr)?;
                        self.context.set_variable("if_condition", VimScope::Vim, VimValue::Boolean(value.to_boolean()));
                    }
                }
            } else {
                return Err(io::Error::new(io::ErrorKind::InvalidInput, "elseif without if"));
            }
        } else {
            return Err(io::Error::new(io::ErrorKind::InvalidInput, "elseif without if"));
        }
        
        Ok(())
    }
    
    /// Execute an endif command
    fn execute_endif(&mut self) -> io::Result<()> {
        // Check if we're in an if block
        if let Some(if_active) = self.context.get_variable("if_active", VimScope::Vim) {
            if if_active.to_boolean() {
                // Clear the if flags
                self.context.set_variable("if_active", VimScope::Vim, VimValue::Boolean(false));
                self.context.set_variable("if_condition", VimScope::Vim, VimValue::Boolean(false));
            } else {
                return Err(io::Error::new(io::ErrorKind::InvalidInput, "endif without if"));
            }
        } else {
            return Err(io::Error::new(io::ErrorKind::InvalidInput, "endif without if"));
        }
        
        Ok(())
    }
    
    /// Execute a while command
    fn execute_while(&mut self, line: &str) -> io::Result<()> {
        // Parse the while command
        let expr = line[6..].trim();
        
        // Evaluate the expression
        let value = self.context.evaluate_expression(expr)?;
        
        // Check if the condition is true
        if value.to_boolean() {
            // Set a flag to indicate that we're in a while block
            self.context.set_variable("while_active", VimScope::Vim, VimValue::Boolean(true));
            self.context.set_variable("while_condition", VimScope::Vim, VimValue::String(expr.to_string()));
            self.context.set_variable("while_line", VimScope::Vim, VimValue::Integer(0));
        } else {
            // Set a flag to indicate that we're in a while block but the condition is false
            self.context.set_variable("while_active", VimScope::Vim, VimValue::Boolean(true));
            self.context.set_variable("while_condition", VimScope::Vim, VimValue::String(expr.to_string()));
            self.context.set_variable("while_line", VimScope::Vim, VimValue::Integer(-1));
        }
        
        Ok(())
    }
    
    /// Execute an endwhile command
    fn execute_endwhile(&mut self) -> io::Result<()> {
        // Check if we're in a while block
        if let Some(while_active) = self.context.get_variable("while_active", VimScope::Vim) {
            if while_active.to_boolean() {
                // Get the while condition
                if let Some(while_condition) = self.context.get_variable("while_condition", VimScope::Vim) {
                    // Evaluate the condition
                    let expr = while_condition.to_string();
                    let value = self.context.evaluate_expression(&expr)?;
                    
                    // Check if the condition is still true
                    if value.to_boolean() {
                        // Set the line to 0 to indicate that we should continue the loop
                        self.context.set_variable("while_line", VimScope::Vim, VimValue::Integer(0));
                    } else {
                        // Clear the while flags
                        self.context.set_variable("while_active", VimScope::Vim, VimValue::Boolean(false));
                        self.context.set_variable("while_condition", VimScope::Vim, VimValue::String("".to_string()));
                        self.context.set_variable("while_line", VimScope::Vim, VimValue::Integer(-1));
                    }
                }
            } else {
                return Err(io::Error::new(io::ErrorKind::InvalidInput, "endwhile without while"));
            }
        } else {
            return Err(io::Error::new(io::ErrorKind::InvalidInput, "endwhile without while"));
        }
        
        Ok(())
    }
    
    /// Execute a for command
    fn execute_for(&mut self, line: &str) -> io::Result<()> {
        // Parse the for command
        let expr = line[4..].trim();
        
        // Split the expression into variable and list
        let parts: Vec<&str> = expr.splitn(2, " in ").collect();
        if parts.len() != 2 {
            return Err(io::Error::new(io::ErrorKind::InvalidInput, "Invalid for command"));
        }
        
        let var_name = parts[0].trim();
        let list_expr = parts[1].trim();
        
        // Evaluate the list expression
        let list_value = self.context.evaluate_expression(list_expr)?;
        
        // Convert the value to a list
        let list = match list_value {
            VimValue::List(list) => list,
            VimValue::String(s) => {
                // Split the string into characters
                let mut list = Vec::new();
                for c in s.chars() {
                    list.push(VimValue::String(c.to_string()));
                }
                list
            },
            _ => {
                // Convert to a list with a single element
                vec![list_value]
            }
        };
        
        // Set the for loop variables
        self.context.set_variable("for_active", VimScope::Vim, VimValue::Boolean(true));
        self.context.set_variable("for_var", VimScope::Vim, VimValue::String(var_name.to_string()));
        self.context.set_variable("for_list", VimScope::Vim, VimValue::List(list.clone()));
        self.context.set_variable("for_index", VimScope::Vim, VimValue::Integer(0));
        
        // Set the loop variable to the first element if the list is not empty
        if !list.is_empty() {
            let (name, scope) = self.context.parse_variable_name(var_name);
            self.context.set_variable(&name, scope, list[0].clone());
        }
        
        Ok(())
    }
    
    /// Execute an endfor command
    fn execute_endfor(&mut self) -> io::Result<()> {
        // Check if we're in a for block
        if let Some(for_active) = self.context.get_variable("for_active", VimScope::Vim) {
            if for_active.to_boolean() {
                // Get the for loop variables
                let for_var = self.context.get_variable("for_var", VimScope::Vim).unwrap_or(VimValue::String("".to_string()));
                let for_list = self.context.get_variable("for_list", VimScope::Vim).unwrap_or(VimValue::List(Vec::new()));
                let for_index = self.context.get_variable("for_index", VimScope::Vim).unwrap_or(VimValue::Integer(0));
                
                // Get the list and index
                let list = match for_list {
                    VimValue::List(list) => list,
                    _ => Vec::new(),
                };
                let index = for_index.to_integer() as usize;
                
                // Check if we've reached the end of the list
                if index + 1 < list.len() {
                    // Increment the index
                    self.context.set_variable("for_index", VimScope::Vim, VimValue::Integer((index + 1) as i64));
                    
                    // Set the loop variable to the next element
                    let (name, scope) = self.context.parse_variable_name(&for_var.to_string());
                    self.context.set_variable(&name, scope, list[index + 1].clone());
                } else {
                    // Clear the for loop variables
                    self.context.set_variable("for_active", VimScope::Vim, VimValue::Boolean(false));
                    self.context.set_variable("for_var", VimScope::Vim, VimValue::String("".to_string()));
                    self.context.set_variable("for_list", VimScope::Vim, VimValue::List(Vec::new()));
                    self.context.set_variable("for_index", VimScope::Vim, VimValue::Integer(-1));
                }
            } else {
                return Err(io::Error::new(io::ErrorKind::InvalidInput, "endfor without for"));
            }
        } else {
            return Err(io::Error::new(io::ErrorKind::InvalidInput, "endfor without for"));
        }
        
        Ok(())
    }
    
    /// Execute a function command
    fn execute_function(&mut self, line: &str) -> io::Result<()> {
        // Parse the function command
        let mut parts = line.splitn(2, ' ');
        let cmd = parts.next().unwrap_or(""); // "function" or "function!"
        let func_def = parts.next().unwrap_or("").trim();
        
        // Check if it's a function! command (overwrite existing function)
        let bang = cmd.ends_with('!');
        
        // Parse the function name and arguments
        let mut parts = func_def.splitn(2, '(');
        if parts.clone().count() < 2 {
            return Err(io::Error::new(io::ErrorKind::InvalidInput, "Invalid function definition"));
        }
        
        let func_name = parts.next().unwrap().trim();
        let args_str = parts.next().unwrap().trim();
        
        // Remove the trailing ')'
        let args_str = if args_str.ends_with(')') {
            &args_str[..args_str.len() - 1]
        } else {
            return Err(io::Error::new(io::ErrorKind::InvalidInput, "Invalid function definition"));
        };
        
        // Parse the arguments
        let mut args = Vec::new();
        if !args_str.is_empty() {
            for arg in args_str.split(',') {
                let arg = arg.trim();
                args.push(arg.to_string());
            }
        }
        
        // Check if the function already exists
        if !bang && self.context.get_function(func_name).is_some() {
            return Err(io::Error::new(io::ErrorKind::AlreadyExists, format!("Function already exists: {}", func_name)));
        }
        
        // Set a flag to indicate that we're in a function definition
        self.context.set_variable("function_active", VimScope::Vim, VimValue::Boolean(true));
        self.context.set_variable("function_name", VimScope::Vim, VimValue::String(func_name.to_string()));
        self.context.set_variable("function_args", VimScope::Vim, VimValue::List(args.iter().map(|arg| VimValue::String(arg.clone())).collect()));
        self.context.set_variable("function_body", VimScope::Vim, VimValue::List(Vec::new()));
        
        // Check if the function is script-local
        let is_script_local = func_name.starts_with("s:");
        self.context.set_variable("function_script_local", VimScope::Vim, VimValue::Boolean(is_script_local));
        
        Ok(())
    }
    
    /// Execute an endfunction command
    fn execute_endfunction(&mut self) -> io::Result<()> {
        // Check if we're in a function definition
        if let Some(function_active) = self.context.get_variable("function_active", VimScope::Vim) {
            if function_active.to_boolean() {
                // Get the function name, arguments, and body
                let function_name = self.context.get_variable("function_name", VimScope::Vim).unwrap_or(VimValue::String("".to_string()));
                let function_args = self.context.get_variable("function_args", VimScope::Vim).unwrap_or(VimValue::List(Vec::new()));
                let function_body = self.context.get_variable("function_body", VimScope::Vim).unwrap_or(VimValue::List(Vec::new()));
                let function_script_local = self.context.get_variable("function_script_local", VimScope::Vim).unwrap_or(VimValue::Boolean(false));
                
                // Convert the arguments to strings
                let args = match function_args {
                    VimValue::List(list) => {
                        list.iter().map(|arg| arg.to_string()).collect()
                    },
                    _ => Vec::new(),
                };
                
                // Convert the body to strings
                let body = match function_body {
                    VimValue::List(list) => {
                        list.iter().map(|line| line.to_string()).collect()
                    },
                    _ => Vec::new(),
                };
                
                // Create the function
                let function = VimFunction::new(
                    &function_name.to_string(),
                    args,
                    body,
                    function_script_local.to_boolean(),
                    if function_script_local.to_boolean() { Some(self.context.script_id) } else { None },
                    0,
                );
                
                // Add the function to the context
                self.context.set_function(function);
                
                // Clear the function definition flags
                self.context.set_variable("function_active", VimScope::Vim, VimValue::Boolean(false));
                self.context.set_variable("function_name", VimScope::Vim, VimValue::String("".to_string()));
                self.context.set_variable("function_args", VimScope::Vim, VimValue::List(Vec::new()));
                self.context.set_variable("function_body", VimScope::Vim, VimValue::List(Vec::new()));
                self.context.set_variable("function_script_local", VimScope::Vim, VimValue::Boolean(false));
            } else {
                return Err(io::Error::new(io::ErrorKind::InvalidInput, "endfunction without function"));
            }
        } else {
            return Err(io::Error::new(io::ErrorKind::InvalidInput, "endfunction without function"));
        }
        
        Ok(())
    }
    
    /// Execute a return command
    fn execute_return(&mut self, line: &str) -> io::Result<()> {
        // Parse the return command
        let expr = if line.len() > 6 {
            line[6..].trim()
        } else {
            ""
        };
        
        // Evaluate the expression
        let value = if expr.is_empty() {
            VimValue::Integer(0)
        } else {
            self.context.evaluate_expression(expr)?
        };
        
        // Check if we're in a function
        if self.context.function_stack.is_empty() {
            return Err(io::Error::new(io::ErrorKind::InvalidInput, "return outside of function"));
        }
        
        // Set the return value
        self.context.set_variable("return_value", VimScope::Vim, value);
        
        // Set a flag to indicate that we're returning
        self.context.set_variable("returning", VimScope::Vim, VimValue::Boolean(true));
        
        Ok(())
    }
    
    /// Execute a delfunction command
    fn execute_delfunction(&mut self, line: &str) -> io::Result<()> {
        // Parse the delfunction command
        let func_name = line[12..].trim();
        
        // Remove the function
        self.context.functions.remove(func_name);
        
        Ok(())
    }
    
    /// Execute a silent command
    fn execute_silent(&mut self, line: &str) -> io::Result<()> {
        // Parse the silent command
        let cmd = line[7..].trim();
        
        // Execute the command silently
        // In a real implementation, this would redirect output
        self.execute_line(cmd)
    }
    
    /// Execute a set command
    fn execute_set(&mut self, line: &str) -> io::Result<()> {
        // Parse the set command
        let options = line[4..].trim();
        
        // TODO: Implement set command
        
        Ok(())
    }
    
    /// Execute a command
    fn execute_command(&mut self, cmd: &str) -> io::Result<()> {
        // Get the command registry
        let registry = self.context.command_registry.clone();
        
        // Lock the registry
        let registry = match registry.lock() {
            Ok(registry) => registry,
            Err(_) => return Err(io::Error::new(io::ErrorKind::Other, "Failed to lock command registry")),
        };
        
        // Parse the command
        let parts: Vec<&str> = cmd.splitn(2, ' ').collect();
        let cmd_name = parts[0];
        let args = if parts.len() > 1 { parts[1] } else { "" };
        
        // Create an Ex command
        let ex_cmd = crate::command::ExCommand {
            name: cmd_name.to_string(),
            args: args.to_string(),
            range: None,
            count: None,
            bang: false,
            reg: None,
            mods: Vec::new(),
        };
        
        // Execute the command
        match registry.execute(&ex_cmd) {
            Ok(_) => Ok(()),
            Err(err) => Err(io::Error::new(io::ErrorKind::Other, format!("Command error: {}", err))),
        }
    }
}