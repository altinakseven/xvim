//! Tag command handlers
//!
//! This module implements handlers for tag commands.

use crate::command::{ExCommand, ExCommandError, ExCommandResult, ExCommandRegistry};
use std::io::Read;
use std::fs::File;
use std::io::Read;
use std::path::PathBuf;
use std::io::Read;
use std::fs::File;
use std::io::Read;
use std::path::Path;
use std::io::Read;
use std::fs::File;
use std::io::Read;
use std::path::PathBuf;
use std::io::Read;
use std::fs::File;
use std::io::Read;
use std::sync::Mutex;
use std::io::Read;
use std::fs::File;
use std::io::Read;
use std::path::PathBuf;
use std::io::Read;
use std::fs::File;
use std::io::Read;
use std::path::Path;
use std::io::Read;
use std::fs::File;
use std::io::Read;
use std::path::PathBuf;
use std::io::Read;
use std::fs::File;
use std::io::Read;
use std::sync::Arc;
use std::io::Read;
use std::fs::File;
use std::io::Read;
use std::path::PathBuf;
use std::io::Read;
use std::fs::File;
use std::io::Read;
use std::path::Path;
use std::io::Read;
use std::fs::File;
use std::io::Read;
use std::path::PathBuf;
use std::io::Read;
use std::fs::File;
use std::io::Read;
use std::sync::Mutex;
use std::io::Read;
use std::fs::File;
use std::io::Read;
use std::path::PathBuf;
use std::io::Read;
use std::fs::File;
use std::io::Read;
use std::path::Path;
use std::io::Read;
use std::fs::File;
use std::io::Read;
use std::path::PathBuf;
use std::io::Read;
use std::fs::File;
use std::io::Read;
use std::collections::HashMap;
use std::io::Read;
use std::fs::File;
use std::io::Read;
use std::path::PathBuf;
use std::io::Read;
use std::fs::File;
use std::io::Read;
use std::path::Path;
use std::io::Read;
use std::fs::File;
use std::io::Read;
use std::path::PathBuf;
use std::io::Read;
use std::fs::File;
use std::io::Read;
use std::sync::Mutex;
use std::io::Read;
use std::fs::File;
use std::io::Read;
use std::path::PathBuf;
use std::io::Read;
use std::fs::File;
use std::io::Read;
use std::path::Path;
use std::io::Read;
use std::fs::File;
use std::io::Read;
use std::path::PathBuf;
use std::io::Read;
use std::fs::File;
use std::io::Read;
use std::sync::Arc;
use std::io::Read;
use std::fs::File;
use std::io::Read;
use std::path::PathBuf;
use std::io::Read;
use std::fs::File;
use std::io::Read;
use std::path::Path;
use std::io::Read;
use std::fs::File;
use std::io::Read;
use std::path::PathBuf;
use std::io::Read;
use std::fs::File;
use std::io::Read;
use std::sync::Mutex;
use std::io::Read;
use std::fs::File;
use std::io::Read;
use std::path::PathBuf;
use std::io::Read;
use std::fs::File;
use std::io::Read;
use std::path::Path;
use std::io::Read;
use std::fs::File;
use std::io::Read;
use std::path::PathBuf;
use std::io::Read;
use std::fs::File;
use std::io::Read;
use crate::editor::Editor;
use std::io::Read;
use std::fs::File;
use std::io::Read;
use std::path::PathBuf;
use std::io::Read;
use std::fs::File;
use std::io::Read;
use std::path::Path;
use std::io::Read;
use std::fs::File;
use std::io::Read;
use std::path::PathBuf;
use std::io::Read;
use std::fs::File;
use std::io::Read;
use std::sync::Mutex;
use std::io::Read;
use std::fs::File;
use std::io::Read;
use std::path::PathBuf;
use std::io::Read;
use std::fs::File;
use std::io::Read;
use std::path::Path;
use std::io::Read;
use std::fs::File;
use std::io::Read;
use std::path::PathBuf;
use std::io::Read;
use std::fs::File;
use std::io::Read;
use std::sync::Arc;
use std::io::Read;
use std::fs::File;
use std::io::Read;
use std::path::PathBuf;
use std::io::Read;
use std::fs::File;
use std::io::Read;
use std::path::Path;
use std::io::Read;
use std::fs::File;
use std::io::Read;
use std::path::PathBuf;
use std::io::Read;
use std::fs::File;
use std::io::Read;
use std::sync::Mutex;
use std::io::Read;
use std::fs::File;
use std::io::Read;
use std::path::PathBuf;
use std::io::Read;
use std::fs::File;
use std::io::Read;
use std::path::Path;
use std::io::Read;
use std::fs::File;
use std::io::Read;
use std::path::PathBuf;
use std::io::Read;
use std::fs::File;
use std::io::Read;
use std::collections::HashMap;
use std::io::Read;
use std::fs::File;
use std::io::Read;
use std::path::PathBuf;
use std::io::Read;
use std::fs::File;
use std::io::Read;
use std::path::Path;
use std::io::Read;
use std::fs::File;
use std::io::Read;
use std::path::PathBuf;
use std::io::Read;
use std::fs::File;
use std::io::Read;
use std::sync::Mutex;
use std::io::Read;
use std::fs::File;
use std::io::Read;
use std::path::PathBuf;
use std::io::Read;
use std::fs::File;
use std::io::Read;
use std::path::Path;
use std::io::Read;
use std::fs::File;
use std::io::Read;
use std::path::PathBuf;
use std::io::Read;
use std::fs::File;
use std::io::Read;
use std::sync::Arc;
use std::io::Read;
use std::fs::File;
use std::io::Read;
use std::path::PathBuf;
use std::io::Read;
use std::fs::File;
use std::io::Read;
use std::path::Path;
use std::io::Read;
use std::fs::File;
use std::io::Read;
use std::path::PathBuf;
use std::io::Read;
use std::fs::File;
use std::io::Read;
use std::sync::Mutex;
use std::io::Read;
use std::fs::File;
use std::io::Read;
use std::path::PathBuf;
use std::io::Read;
use std::fs::File;
use std::io::Read;
use std::path::Path;
use std::io::Read;
use std::fs::File;
use std::io::Read;
use std::path::PathBuf;
use std::io::Read;
use std::fs::File;
use std::io::Read;
use crate::cursor::CursorPosition;
use std::io::Read;
use std::fs::File;
use std::io::Read;
use std::path::PathBuf;
use std::io::Read;
use std::fs::File;
use std::io::Read;
use std::path::Path;
use std::io::Read;
use std::fs::File;
use std::io::Read;
use std::path::PathBuf;
use std::io::Read;
use std::fs::File;
use std::io::Read;
use std::sync::Mutex;
use std::io::Read;
use std::fs::File;
use std::io::Read;
use std::path::PathBuf;
use std::io::Read;
use std::fs::File;
use std::io::Read;
use std::path::Path;
use std::io::Read;
use std::fs::File;
use std::io::Read;
use std::path::PathBuf;
use std::io::Read;
use std::fs::File;
use std::io::Read;
use std::sync::Arc;
use std::io::Read;
use std::fs::File;
use std::io::Read;
use std::path::PathBuf;
use std::io::Read;
use std::fs::File;
use std::io::Read;
use std::path::Path;
use std::io::Read;
use std::fs::File;
use std::io::Read;
use std::path::PathBuf;
use std::io::Read;
use std::fs::File;
use std::io::Read;
use std::sync::Mutex;
use std::io::Read;
use std::fs::File;
use std::io::Read;
use std::path::PathBuf;
use std::io::Read;
use std::fs::File;
use std::io::Read;
use std::path::Path;
use std::io::Read;
use std::fs::File;
use std::io::Read;
use std::path::PathBuf;
use std::io::Read;
use std::fs::File;
use std::io::Read;
use std::collections::HashMap;
use std::io::Read;
use std::fs::File;
use std::io::Read;
use std::path::PathBuf;
use std::io::Read;
use std::fs::File;
use std::io::Read;
use std::path::Path;
use std::io::Read;
use std::fs::File;
use std::io::Read;
use std::path::PathBuf;
use std::io::Read;
use std::fs::File;
use std::io::Read;
use std::sync::Mutex;
use std::io::Read;
use std::fs::File;
use std::io::Read;
use std::path::PathBuf;
use std::io::Read;
use std::fs::File;
use std::io::Read;
use std::path::Path;
use std::io::Read;
use std::fs::File;
use std::io::Read;
use std::path::PathBuf;
use std::io::Read;
use std::fs::File;
use std::io::Read;
use std::sync::Arc;
use std::io::Read;
use std::fs::File;
use std::io::Read;
use std::path::PathBuf;
use std::io::Read;
use std::fs::File;
use std::io::Read;
use std::path::Path;
use std::io::Read;
use std::fs::File;
use std::io::Read;
use std::path::PathBuf;
use std::io::Read;
use std::fs::File;
use std::io::Read;
use std::sync::Mutex;
use std::io::Read;
use std::fs::File;
use std::io::Read;
use std::path::PathBuf;
use std::io::Read;
use std::fs::File;
use std::io::Read;
use std::path::Path;
use std::io::Read;
use std::fs::File;
use std::io::Read;
use std::path::PathBuf;
use std::io::Read;
use std::fs::File;
use std::io::Read;
use std::collections::{HashMap, VecDeque};
use std::io::Read;
use std::fs::File;
use std::io::Read;
use std::path::PathBuf;
use std::io::Read;
use std::fs::File;
use std::io::Read;
use std::path::Path;
use std::io::Read;
use std::fs::File;
use std::io::Read;
use std::path::PathBuf;
use std::io::Read;
use std::fs::File;
use std::io::Read;
use std::sync::Mutex;
use std::io::Read;
use std::fs::File;
use std::io::Read;
use std::path::PathBuf;
use std::io::Read;
use std::fs::File;
use std::io::Read;
use std::path::Path;
use std::io::Read;
use std::fs::File;
use std::io::Read;
use std::path::PathBuf;
use std::io::Read;
use std::fs::File;
use std::io::Read;
use std::sync::Arc;
use std::io::Read;
use std::fs::File;
use std::io::Read;
use std::path::PathBuf;
use std::io::Read;
use std::fs::File;
use std::io::Read;
use std::path::Path;
use std::io::Read;
use std::fs::File;
use std::io::Read;
use std::path::PathBuf;
use std::io::Read;
use std::fs::File;
use std::io::Read;
use std::sync::Mutex;
use std::io::Read;
use std::fs::File;
use std::io::Read;
use std::path::PathBuf;
use std::io::Read;
use std::fs::File;
use std::io::Read;
use std::path::Path;
use std::io::Read;
use std::fs::File;
use std::io::Read;
use std::path::PathBuf;
use std::io::Read;
use std::fs::File;
use std::io::Read;
use std::collections::HashMap;
use std::io::Read;
use std::fs::File;
use std::io::Read;
use std::path::PathBuf;
use std::io::Read;
use std::fs::File;
use std::io::Read;
use std::path::Path;
use std::io::Read;
use std::fs::File;
use std::io::Read;
use std::path::PathBuf;
use std::io::Read;
use std::fs::File;
use std::io::Read;
use std::sync::Mutex;
use std::io::Read;
use std::fs::File;
use std::io::Read;
use std::path::PathBuf;
use std::io::Read;
use std::fs::File;
use std::io::Read;
use std::path::Path;
use std::io::Read;
use std::fs::File;
use std::io::Read;
use std::path::PathBuf;
use std::io::Read;
use std::fs::File;
use std::io::Read;
use std::sync::Arc;
use std::io::Read;
use std::fs::File;
use std::io::Read;
use std::path::PathBuf;
use std::io::Read;
use std::fs::File;
use std::io::Read;
use std::path::Path;
use std::io::Read;
use std::fs::File;
use std::io::Read;
use std::path::PathBuf;
use std::io::Read;
use std::fs::File;
use std::io::Read;
use std::sync::Mutex;
use std::io::Read;
use std::fs::File;
use std::io::Read;
use std::path::PathBuf;
use std::io::Read;
use std::fs::File;
use std::io::Read;
use std::path::Path;
use std::io::Read;
use std::fs::File;
use std::io::Read;
use std::path::PathBuf;
use std::io::Read;
use std::fs::File;
use std::io::Read;
use std::fs::{self, File};
use std::io::Read;
use std::fs::File;
use std::io::Read;
use std::path::PathBuf;
use std::io::Read;
use std::fs::File;
use std::io::Read;
use std::path::Path;
use std::io::Read;
use std::fs::File;
use std::io::Read;
use std::path::PathBuf;
use std::io::Read;
use std::fs::File;
use std::io::Read;
use std::sync::Mutex;
use std::io::Read;
use std::fs::File;
use std::io::Read;
use std::path::PathBuf;
use std::io::Read;
use std::fs::File;
use std::io::Read;
use std::path::Path;
use std::io::Read;
use std::fs::File;
use std::io::Read;
use std::path::PathBuf;
use std::io::Read;
use std::fs::File;
use std::io::Read;
use std::sync::Arc;
use std::io::Read;
use std::fs::File;
use std::io::Read;
use std::path::PathBuf;
use std::io::Read;
use std::fs::File;
use std::io::Read;
use std::path::Path;
use std::io::Read;
use std::fs::File;
use std::io::Read;
use std::path::PathBuf;
use std::io::Read;
use std::fs::File;
use std::io::Read;
use std::sync::Mutex;
use std::io::Read;
use std::fs::File;
use std::io::Read;
use std::path::PathBuf;
use std::io::Read;
use std::fs::File;
use std::io::Read;
use std::path::Path;
use std::io::Read;
use std::fs::File;
use std::io::Read;
use std::path::PathBuf;
use std::io::Read;
use std::fs::File;
use std::io::Read;
use std::collections::HashMap;
use std::io::Read;
use std::fs::File;
use std::io::Read;
use std::path::PathBuf;
use std::io::Read;
use std::fs::File;
use std::io::Read;
use std::path::Path;
use std::io::Read;
use std::fs::File;
use std::io::Read;
use std::path::PathBuf;
use std::io::Read;
use std::fs::File;
use std::io::Read;
use std::sync::Mutex;
use std::io::Read;
use std::fs::File;
use std::io::Read;
use std::path::PathBuf;
use std::io::Read;
use std::fs::File;
use std::io::Read;
use std::path::Path;
use std::io::Read;
use std::fs::File;
use std::io::Read;
use std::path::PathBuf;
use std::io::Read;
use std::fs::File;
use std::io::Read;
use std::sync::Arc;
use std::io::Read;
use std::fs::File;
use std::io::Read;
use std::path::PathBuf;
use std::io::Read;
use std::fs::File;
use std::io::Read;
use std::path::Path;
use std::io::Read;
use std::fs::File;
use std::io::Read;
use std::path::PathBuf;
use std::io::Read;
use std::fs::File;
use std::io::Read;
use std::sync::Mutex;
use std::io::Read;
use std::fs::File;
use std::io::Read;
use std::path::PathBuf;
use std::io::Read;
use std::fs::File;
use std::io::Read;
use std::path::Path;
use std::io::Read;
use std::fs::File;
use std::io::Read;
use std::path::PathBuf;
use std::io::Read;
use std::fs::File;
use std::io::Read;
use std::io::{self, BufRead, BufReader, Read};
use std::io::Read;
use std::fs::File;
use std::io::Read;
use std::path::PathBuf;
use std::io::Read;
use std::fs::File;
use std::io::Read;
use std::path::Path;
use std::io::Read;
use std::fs::File;
use std::io::Read;
use std::path::PathBuf;
use std::io::Read;
use std::fs::File;
use std::io::Read;
use std::sync::Mutex;
use std::io::Read;
use std::fs::File;
use std::io::Read;
use std::path::PathBuf;
use std::io::Read;
use std::fs::File;
use std::io::Read;
use std::path::Path;
use std::io::Read;
use std::fs::File;
use std::io::Read;
use std::path::PathBuf;
use std::io::Read;
use std::fs::File;
use std::io::Read;
use std::sync::Arc;
use std::io::Read;
use std::fs::File;
use std::io::Read;
use std::path::PathBuf;
use std::io::Read;
use std::fs::File;
use std::io::Read;
use std::path::Path;
use std::io::Read;
use std::fs::File;
use std::io::Read;
use std::path::PathBuf;
use std::io::Read;
use std::fs::File;
use std::io::Read;
use std::sync::Mutex;
use std::io::Read;
use std::fs::File;
use std::io::Read;
use std::path::PathBuf;
use std::io::Read;
use std::fs::File;
use std::io::Read;
use std::path::Path;
use std::io::Read;
use std::fs::File;
use std::io::Read;
use std::path::PathBuf;
use std::io::Read;
use std::fs::File;
use std::io::Read;
use std::collections::HashMap;
use std::io::Read;
use std::fs::File;
use std::io::Read;
use std::path::PathBuf;
use std::io::Read;
use std::fs::File;
use std::io::Read;
use std::path::Path;
use std::io::Read;
use std::fs::File;
use std::io::Read;
use std::path::PathBuf;
use std::io::Read;
use std::fs::File;
use std::io::Read;
use std::sync::Mutex;
use std::io::Read;
use std::fs::File;
use std::io::Read;
use std::path::PathBuf;
use std::io::Read;
use std::fs::File;
use std::io::Read;
use std::path::Path;
use std::io::Read;
use std::fs::File;
use std::io::Read;
use std::path::PathBuf;
use std::io::Read;
use std::fs::File;
use std::io::Read;
use std::sync::Arc;
use std::io::Read;
use std::fs::File;
use std::io::Read;
use std::path::PathBuf;
use std::io::Read;
use std::fs::File;
use std::io::Read;
use std::path::Path;
use std::io::Read;
use std::fs::File;
use std::io::Read;
use std::path::PathBuf;
use std::io::Read;
use std::fs::File;
use std::io::Read;
use std::sync::Mutex;
use std::io::Read;
use std::fs::File;
use std::io::Read;
use std::path::PathBuf;
use std::io::Read;
use std::fs::File;
use std::io::Read;
use std::path::Path;
use std::io::Read;
use std::fs::File;
use std::io::Read;
use std::path::PathBuf;
use std::io::Read;
use std::fs::File;
use std::io::Read;
use std::path::{Path, PathBuf};
use std::io::Read;
use std::fs::File;
use std::io::Read;
use std::path::PathBuf;
use std::io::Read;
use std::fs::File;
use std::io::Read;
use std::path::Path;
use std::io::Read;
use std::fs::File;
use std::io::Read;
use std::path::PathBuf;
use std::io::Read;
use std::fs::File;
use std::io::Read;
use std::sync::Mutex;
use std::io::Read;
use std::fs::File;
use std::io::Read;
use std::path::PathBuf;
use std::io::Read;
use std::fs::File;
use std::io::Read;
use std::path::Path;
use std::io::Read;
use std::fs::File;
use std::io::Read;
use std::path::PathBuf;
use std::io::Read;
use std::fs::File;
use std::io::Read;
use std::sync::Arc;
use std::io::Read;
use std::fs::File;
use std::io::Read;
use std::path::PathBuf;
use std::io::Read;
use std::fs::File;
use std::io::Read;
use std::path::Path;
use std::io::Read;
use std::fs::File;
use std::io::Read;
use std::path::PathBuf;
use std::io::Read;
use std::fs::File;
use std::io::Read;
use std::sync::Mutex;
use std::io::Read;
use std::fs::File;
use std::io::Read;
use std::path::PathBuf;
use std::io::Read;
use std::fs::File;
use std::io::Read;
use std::path::Path;
use std::io::Read;
use std::fs::File;
use std::io::Read;
use std::path::PathBuf;
use std::io::Read;
use std::fs::File;
use std::io::Read;
use std::collections::HashMap;
use std::io::Read;
use std::fs::File;
use std::io::Read;
use std::path::PathBuf;
use std::io::Read;
use std::fs::File;
use std::io::Read;
use std::path::Path;
use std::io::Read;
use std::fs::File;
use std::io::Read;
use std::path::PathBuf;
use std::io::Read;
use std::fs::File;
use std::io::Read;
use std::sync::Mutex;
use std::io::Read;
use std::fs::File;
use std::io::Read;
use std::path::PathBuf;
use std::io::Read;
use std::fs::File;
use std::io::Read;
use std::path::Path;
use std::io::Read;
use std::fs::File;
use std::io::Read;
use std::path::PathBuf;
use std::io::Read;
use std::fs::File;
use std::io::Read;
use std::sync::Arc;
use std::io::Read;
use std::fs::File;
use std::io::Read;
use std::path::PathBuf;
use std::io::Read;
use std::fs::File;
use std::io::Read;
use std::path::Path;
use std::io::Read;
use std::fs::File;
use std::io::Read;
use std::path::PathBuf;
use std::io::Read;
use std::fs::File;
use std::io::Read;
use std::sync::Mutex;
use std::io::Read;
use std::fs::File;
use std::io::Read;
use std::path::PathBuf;
use std::io::Read;
use std::fs::File;
use std::io::Read;
use std::path::Path;
use std::io::Read;
use std::fs::File;
use std::io::Read;
use std::path::PathBuf;
use std::io::Read;
use std::fs::File;
use std::io::Read;
use std::sync::{Arc, Mutex};
use std::io::Read;
use std::fs::File;
use std::io::Read;
use std::path::PathBuf;
use std::io::Read;
use std::fs::File;
use std::io::Read;
use std::path::Path;
use std::io::Read;
use std::fs::File;
use std::io::Read;
use std::path::PathBuf;
use std::io::Read;
use std::fs::File;
use std::io::Read;
use std::sync::Mutex;
use std::io::Read;
use std::fs::File;
use std::io::Read;
use std::path::PathBuf;
use std::io::Read;
use std::fs::File;
use std::io::Read;
use std::path::Path;
use std::io::Read;
use std::fs::File;
use std::io::Read;
use std::path::PathBuf;
use std::io::Read;
use std::fs::File;
use std::io::Read;
use std::sync::Arc;
use std::io::Read;
use std::fs::File;
use std::io::Read;
use std::path::PathBuf;
use std::io::Read;
use std::fs::File;
use std::io::Read;
use std::path::Path;
use std::io::Read;
use std::fs::File;
use std::io::Read;
use std::path::PathBuf;
use std::io::Read;
use std::fs::File;
use std::io::Read;
use std::sync::Mutex;
use std::io::Read;
use std::fs::File;
use std::io::Read;
use std::path::PathBuf;
use std::io::Read;
use std::fs::File;
use std::io::Read;
use std::path::Path;
use std::io::Read;
use std::fs::File;
use std::io::Read;
use std::path::PathBuf;
use std::io::Read;
use std::fs::File;
use std::io::Read;
use std::collections::HashMap;
use std::io::Read;
use std::fs::File;
use std::io::Read;
use std::path::PathBuf;
use std::io::Read;
use std::fs::File;
use std::io::Read;
use std::path::Path;
use std::io::Read;
use std::fs::File;
use std::io::Read;
use std::path::PathBuf;
use std::io::Read;
use std::fs::File;
use std::io::Read;
use std::sync::Mutex;
use std::io::Read;
use std::fs::File;
use std::io::Read;
use std::path::PathBuf;
use std::io::Read;
use std::fs::File;
use std::io::Read;
use std::path::Path;
use std::io::Read;
use std::fs::File;
use std::io::Read;
use std::path::PathBuf;
use std::io::Read;
use std::fs::File;
use std::io::Read;
use std::sync::Arc;
use std::io::Read;
use std::fs::File;
use std::io::Read;
use std::path::PathBuf;
use std::io::Read;
use std::fs::File;
use std::io::Read;
use std::path::Path;
use std::io::Read;
use std::fs::File;
use std::io::Read;
use std::path::PathBuf;
use std::io::Read;
use std::fs::File;
use std::io::Read;
use std::sync::Mutex;
use std::io::Read;
use std::fs::File;
use std::io::Read;
use std::path::PathBuf;
use std::io::Read;
use std::fs::File;
use std::io::Read;
use std::path::Path;
use std::io::Read;
use std::fs::File;
use std::io::Read;
use std::path::PathBuf;
use std::io::Read;
use std::fs::File;
use std::io::Read;

/// Tag entry
#[derive(Debug, Clone)]
pub struct TagEntry {
    /// Tag name
    pub name: String,
    /// File path
    pub file: PathBuf,
    /// Search pattern
    pub pattern: String,
    /// Tag kind (function, class, etc.)
    pub kind: Option<String>,
    /// Line number (if available)
    pub line: Option<usize>,
    /// Additional fields
    pub fields: HashMap<String, String>,
}

impl TagEntry {
    /// Create a new tag entry
    pub fn new(name: &str, file: &Path, pattern: &str) -> Self {
        Self {
            name: name.to_string(),
            file: file.to_path_buf(),
            pattern: pattern.to_string(),
            kind: None,
            line: None,
            fields: HashMap::new(),
        }
    }

    /// Add a field to the tag entry
    pub fn add_field(&mut self, key: &str, value: &str) {
        match key {
            "kind" => self.kind = Some(value.to_string()),
            "line" => self.line = value.parse::<usize>().ok(),
            _ => {
                self.fields.insert(key.to_string(), value.to_string());
            }
        }
    }
}

/// Tag database
#[derive(Debug)]
pub struct TagDatabase {
    /// Tags by name
    pub tags: HashMap<String, Vec<TagEntry>>,
    /// Tag files
    pub tag_files: Vec<PathBuf>,
    /// Tag stack
    pub tag_stack: VecDeque<(String, usize)>,
    /// Current tag index
    pub current_tag: Option<(String, usize)>,
}

impl TagDatabase {
    /// Create a new tag database
    pub fn new() -> Self {
        Self {
            tags: HashMap::new(),
            tag_files: Vec::new(),
            tag_stack: VecDeque::new(),
            current_tag: None,
        }
    }

    /// Add a tag file
    pub fn add_tag_file(&mut self, path: &Path) -> io::Result<usize> {
        // Check if the file exists
        if !path.exists() {
            return Err(io::Error::new(io::ErrorKind::NotFound, format!("Tag file not found: {}", path.display())));
        }

        // Add the file to the list
        self.tag_files.push(path.to_path_buf());

        // Parse the file
        let count = self.parse_tag_file(path)?;

        Ok(count)
    }

    /// Parse a tag file
    fn parse_tag_file(&mut self, path: &Path) -> io::Result<usize> {
        // Open the file
        let file = File::open(path)?;
        let reader = BufReader::new(file);

        let mut count = 0;

        // Read the file line by line
        for line in reader.lines() {
            let line = line?;

            // Skip comments
            if line.starts_with('!') {
                continue;
            }

            // Parse the line
            if let Some(tag) = self.parse_tag_line(&line) {
                // Add the tag to the database
                let entries = self.tags.entry(tag.name.clone()).or_insert_with(Vec::new);
                entries.push(tag);
                count += 1;
            }
        }

        Ok(count)
    }

    /// Parse a tag line
    fn parse_tag_line(&self, line: &str) -> Option<TagEntry> {
        // Split the line into fields
        let fields: Vec<&str> = line.split('\t').collect();

        if fields.len() < 3 {
            return None;
        }

        // Get the tag name, file, and pattern
        let name = fields[0];
        let file = PathBuf::from(fields[1]);
        let pattern = fields[2];

        // Create a new tag entry
        let mut tag = TagEntry::new(name, &file, pattern);

        // Parse additional fields
        for field in fields.iter().skip(3) {
            if let Some(pos) = field.find(':') {
                let key = &field[..pos];
                let value = &field[pos + 1..];
                tag.add_field(key, value);
            }
        }

        Some(tag)
    }

    /// Find tags by name
    pub fn find_tags(&self, name: &str) -> Option<&Vec<TagEntry>> {
        self.tags.get(name)
    }

    /// Push a tag onto the stack
    pub fn push_tag(&mut self, name: &str, index: usize) {
        // Set the current tag
        self.current_tag = Some((name.to_string(), index));

        // Push the tag onto the stack
        self.tag_stack.push_back((name.to_string(), index));

        // Limit the stack size to 20
        if self.tag_stack.len() > 20 {
            self.tag_stack.pop_front();
        }
    }

    /// Pop a tag from the stack
    pub fn pop_tag(&mut self) -> Option<(String, usize)> {
        // Pop the tag from the stack
        let tag = self.tag_stack.pop_back()?;

        // Set the current tag to the previous one
        self.current_tag = self.tag_stack.back().cloned();

        Some(tag)
    }

    /// Go to the next tag
    pub fn next_tag(&mut self) -> Option<(String, usize)> {
        // Check if we have a current tag
        let (name, index) = self.current_tag.clone()?;

        // Get the tags with this name
        let tags = self.tags.get(&name)?;

        // Check if there's a next tag
        if index + 1 < tags.len() {
            // Set the current tag to the next one
            let next_index = index + 1;
            self.current_tag = Some((name.clone(), next_index));

            // Return the next tag
            Some((name, next_index))
        } else {
            None
        }
    }

    /// Go to the previous tag
    pub fn prev_tag(&mut self) -> Option<(String, usize)> {
        // Check if we have a current tag
        let (name, index) = self.current_tag.clone()?;

        // Check if there's a previous tag
        if index > 0 {
            // Set the current tag to the previous one
            let prev_index = index - 1;
            self.current_tag = Some((name.clone(), prev_index));

            // Return the previous tag
            Some((name, prev_index))
        } else {
            None
        }
    }

    /// Get the current tag
    pub fn current_tag(&self) -> Option<&TagEntry> {
        // Check if we have a current tag
        let (name, index) = self.current_tag.as_ref()?;

        // Get the tags with this name
        let tags = self.tags.get(name)?;

        // Get the current tag
        tags.get(*index)
    }

    /// Clear the tag stack
    pub fn clear_stack(&mut self) {
        self.tag_stack.clear();
        self.current_tag = None;
    }
}

// Global tag database
pub static mut TAG_DATABASE: Option<TagDatabase> = None;

/// Initialize the tag database
pub fn init_tag_database() {
    unsafe {
        if TAG_DATABASE.is_none() {
            TAG_DATABASE = Some(TagDatabase::new());
        }
    }
}

/// Register tag command handlers
pub fn register_tag_handlers(registry: &mut ExCommandRegistry) {
    // Initialize the tag database
    init_tag_database();
    
    // Register tag commands
    registry.register("tag", handle_tag);
    registry.register("tags", handle_tags);
    registry.register("tselect", handle_tselect);
    registry.register("tjump", handle_tjump);
    registry.register("tnext", handle_tnext);
    registry.register("tprevious", handle_tprev);
    registry.register("tfirst", handle_tfirst);
    registry.register("tlast", handle_tlast);
    registry.register("tstack", handle_tstack);
    registry.register("pop", handle_pop);
    registry.register("settagstack", handle_settagstack);
    registry.register("tagfiles", handle_tagfiles);
}

/// Handle the :tag command
fn handle_tag(cmd: &ExCommand) -> ExCommandResult<()> {
    // Get the editor reference
    let editor = unsafe {
        match crate::command::handlers::EDITOR {
            Some(editor_ptr) => &mut *editor_ptr,
            None => return Err(ExCommandError::InvalidCommand("Editor not initialized".to_string())),
        }
    };
    
    // Get the tag database
    let tag_database = unsafe {
        match &mut TAG_DATABASE {
            Some(db) => db,
            None => {
                init_tag_database();
                match &mut TAG_DATABASE {
                    Some(db) => db,
                    None => return Err(ExCommandError::Other("Failed to initialize tag database".to_string())),
                }
            }
        }
    };
    
    // Get the tag name from the command arguments
    let tag_name = match cmd.first_arg() {
        Some(name) => name,
        None => {
            // If no tag name is provided, jump to the current tag
            if let Some(tag) = tag_database.current_tag() {
                // Jump to the tag
                jump_to_tag(editor, tag)?;
                return Ok(());
            } else {
                return Err(ExCommandError::MissingArgument("Tag name required".to_string()));
            }
        }
    };
    
    // Find the tag
    let tags = match tag_database.find_tags(tag_name) {
        Some(tags) => tags,
        None => return Err(ExCommandError::Other(format!("Tag not found: {}", tag_name))),
    };
    
    // Jump to the first tag
    let tag = tags[0].clone();
    
    // Push the tag onto the stack
    tag_database.push_tag(tag_name, 0);
    
    // Jump to the tag
    jump_to_tag(editor, &tag)?;
    
    Ok(())
}

/// Handle the :tags command
fn handle_tags(_cmd: &ExCommand) -> ExCommandResult<()> {
    // Get the tag database
    let tag_database = unsafe {
        match &TAG_DATABASE {
            Some(db) => db,
            None => {
                init_tag_database();
                match &TAG_DATABASE {
                    Some(db) => db,
                    None => return Err(ExCommandError::Other("Failed to initialize tag database".to_string())),
                }
            }
        }
    };
    
    // Display the tag stack
    println!("# TO tag         FROM line  in file/text");
    
    for (i, (name, index)) in tag_database.tag_stack.iter().enumerate() {
        // Get the tag
        if let Some(tags) = tag_database.find_tags(name) {
            if let Some(tag) = tags.get(*index) {
                // Get the line number
                let line = tag.line.unwrap_or(0);
                
                // Display the tag
                println!("{:2} {:1} {:<12} {:4}  {}",
                    i + 1,
                    if Some((name.clone(), *index)) == tag_database.current_tag { ">" } else { " " },
                    name,
                    line,
                    tag.file.display()
                );
            }
        }
    }
    
    Ok(())
}

/// Handle the :tselect command
fn handle_tselect(cmd: &ExCommand) -> ExCommandResult<()> {
    // Get the editor reference
    let editor = unsafe {
        match crate::command::handlers::EDITOR {
            Some(editor_ptr) => &mut *editor_ptr,
            None => return Err(ExCommandError::InvalidCommand("Editor not initialized".to_string())),
        }
    };
    
    // Get the tag database
    let tag_database = unsafe {
        match &mut TAG_DATABASE {
            Some(db) => db,
            None => {
                init_tag_database();
                match &mut TAG_DATABASE {
                    Some(db) => db,
                    None => return Err(ExCommandError::Other("Failed to initialize tag database".to_string())),
                }
            }
        }
    };
    
    // Get the tag name from the command arguments
    let tag_name = match cmd.first_arg() {
        Some(name) => name,
        None => return Err(ExCommandError::MissingArgument("Tag name required".to_string())),
    };
    
    // Find the tag
    let tags = match tag_database.find_tags(tag_name) {
        Some(tags) => tags,
        None => return Err(ExCommandError::Other(format!("Tag not found: {}", tag_name))),
    };
    
    // Display the tags
    println!("# pri kind tag               file");
    
    for (i, tag) in tags.iter().enumerate() {
        // Get the kind
        let kind = tag.kind.as_deref().unwrap_or("");
        
        // Display the tag
        println!("{:2} {:3} {:4} {:<18} {}",
            i + 1,
            "",
            kind,
            tag.name,
            tag.file.display()
        );
    }
    
    // Prompt for selection
    print!("Enter choice (CR to abort): ");
    io::stdout().flush().unwrap();
    
    // Read the selection
    let mut selection = String::new();
    io::stdin().read_line(&mut selection).unwrap();
    
    // Parse the selection
    let selection = selection.trim();
    
    if selection.is_empty() {
        return Ok(());
    }
    
    let index = match selection.parse::<usize>() {
        Ok(n) => n - 1, // Convert to 0-based
        Err(_) => return Err(ExCommandError::InvalidArgument(format!("Invalid selection: {}", selection))),
    };
    
    // Check if the selection is valid
    if index >= tags.len() {
        return Err(ExCommandError::InvalidArgument(format!("Invalid selection: {}", selection)));
    }
    
    // Get the selected tag
    let tag = &tags[index];
    
    // Push the tag onto the stack
    tag_database.push_tag(tag_name, index);
    
    // Jump to the tag
    jump_to_tag(editor, tag)?;
    
    Ok(())
}

/// Handle the :tjump command
fn handle_tjump(cmd: &ExCommand) -> ExCommandResult<()> {
    // Get the editor reference
    let editor = unsafe {
        match crate::command::handlers::EDITOR {
            Some(editor_ptr) => &mut *editor_ptr,
            None => return Err(ExCommandError::InvalidCommand("Editor not initialized".to_string())),
        }
    };
    
    // Get the tag database
    let tag_database = unsafe {
        match &mut TAG_DATABASE {
            Some(db) => db,
            None => {
                init_tag_database();
                match &mut TAG_DATABASE {
                    Some(db) => db,
                    None => return Err(ExCommandError::Other("Failed to initialize tag database".to_string())),
                }
            }
        }
    };
    
    // Get the tag name from the command arguments
    let tag_name = match cmd.first_arg() {
        Some(name) => name,
        None => return Err(ExCommandError::MissingArgument("Tag name required".to_string())),
    };
    
    // Find the tag
    let tags = match tag_database.find_tags(tag_name) {
        Some(tags) => tags,
        None => return Err(ExCommandError::Other(format!("Tag not found: {}", tag_name))),
    };
    
    // If there's only one tag, jump to it
    if tags.len() == 1 {
        // Get the tag
        let tag = tags[0].clone();
        
        // Push the tag onto the stack
        tag_database.push_tag(tag_name, 0);
        
        // Jump to the tag
        jump_to_tag(editor, &tag)?;
        
        return Ok(());
    }
    
    // Otherwise, display the tags and prompt for selection
    handle_tselect(cmd)
}

/// Handle the :tnext command
fn handle_tnext(_cmd: &ExCommand) -> ExCommandResult<()> {
    // Get the editor reference
    let editor = unsafe {
        match crate::command::handlers::EDITOR {
            Some(editor_ptr) => &mut *editor_ptr,
            None => return Err(ExCommandError::InvalidCommand("Editor not initialized".to_string())),
        }
    };
    
    // Get the tag database
    let tag_database = unsafe {
        match &mut TAG_DATABASE {
            Some(db) => db,
            None => {
                init_tag_database();
                match &mut TAG_DATABASE {
                    Some(db) => db,
                    None => return Err(ExCommandError::Other("Failed to initialize tag database".to_string())),
                }
            }
        }
    };
    
    // Go to the next tag
    let (name, index) = match tag_database.next_tag() {
        Some(tag) => tag,
        None => return Err(ExCommandError::Other("No next tag".to_string())),
    };
    
    // Get the tag
    let tags = match tag_database.find_tags(&name) {
        Some(tags) => tags,
        None => return Err(ExCommandError::Other(format!("Tag not found: {}", name))),
    };
    
    // Get the tag
    let tag = match tags.get(index) {
        Some(tag) => tag,
        None => return Err(ExCommandError::Other(format!("Tag index out of range: {}", index))),
    };
    
    // Jump to the tag
    jump_to_tag(editor, tag)?;
    
    Ok(())
}

/// Handle the :tprev command
fn handle_tprev(_cmd: &ExCommand) -> ExCommandResult<()> {
    // Get the editor reference
    let editor = unsafe {
        match crate::command::handlers::EDITOR {
            Some(editor_ptr) => &mut *editor_ptr,
            None => return Err(ExCommandError::InvalidCommand("Editor not initialized".to_string())),
        }
    };
    
    // Get the tag database
    let tag_database = unsafe {
        match &mut TAG_DATABASE {
            Some(db) => db,
            None => {
                init_tag_database();
                match &mut TAG_DATABASE {
                    Some(db) => db,
                    None => return Err(ExCommandError::Other("Failed to initialize tag database".to_string())),
                }
            }
        }
    };
    
    // Go to the previous tag
    let (name, index) = match tag_database.prev_tag() {
        Some(tag) => tag,
        None => return Err(ExCommandError::Other("No previous tag".to_string())),
    };
    
    // Get the tag
    let tags = match tag_database.find_tags(&name) {
        Some(tags) => tags,
        None => return Err(ExCommandError::Other(format!("Tag not found: {}", name))),
    };
    
    // Get the tag
    let tag = match tags.get(index) {
        Some(tag) => tag,
        None => return Err(ExCommandError::Other(format!("Tag index out of range: {}", index))),
    };
    
    // Jump to the tag
    jump_to_tag(editor, tag)?;
    
    Ok(())
}

/// Handle the :tfirst command
fn handle_tfirst(_cmd: &ExCommand) -> ExCommandResult<()> {
    // Get the editor reference
    let editor = unsafe {
        match crate::command::handlers::EDITOR {
            Some(editor_ptr) => &mut *editor_ptr,
            None => return Err(ExCommandError::InvalidCommand("Editor not initialized".to_string())),
        }
    };
    
    // Get the tag database
    let tag_database = unsafe {
        match &mut TAG_DATABASE {
            Some(db) => db,
            None => {
                init_tag_database();
                match &mut TAG_DATABASE {
                    Some(db) => db,
                    None => return Err(ExCommandError::Other("Failed to initialize tag database".to_string())),
                }
            }
        }
    };
    
    // Check if we have a current tag
    let (name, _) = match tag_database.current_tag.clone() {
        Some(tag) => tag,
        None => return Err(ExCommandError::Other("No current tag".to_string())),
    };
    
    // Set the current tag to the first one
    tag_database.current_tag = Some((name.clone(), 0));
    
    // Get the tag
    let tags = match tag_database.find_tags(&name) {
        Some(tags) => tags,
        None => return Err(ExCommandError::Other(format!("Tag not found: {}", name))),
    };
    
    // Get the tag
    let tag = match tags.first() {
        Some(tag) => tag,
        None => return Err(ExCommandError::Other(format!("No tags found for: {}", name))),
    };
    
    // Jump to the tag
    jump_to_tag(editor, tag)?;
    
    Ok(())
}

/// Handle the :tlast command
fn handle_tlast(_cmd: &ExCommand) -> ExCommandResult<()> {
    // Get the editor reference
    let editor = unsafe {
        match crate::command::handlers::EDITOR {
            Some(editor_ptr) => &mut *editor_ptr,
            None => return Err(ExCommandError::InvalidCommand("Editor not initialized".to_string())),
        }
    };
    
    // Get the tag database
    let tag_database = unsafe {
        match &mut TAG_DATABASE {
            Some(db) => db,
            None => {
                init_tag_database();
                match &mut TAG_DATABASE {
                    Some(db) => db,
                    None => return Err(ExCommandError::Other("Failed to initialize tag database".to_string())),
                }
            }
        }
    };
    
    // Check if we have a current tag
    let (name, _) = match tag_database.current_tag.clone() {
        Some(tag) => tag,
        None => return Err(ExCommandError::Other("No current tag".to_string())),
    };
    
    // Get the tag
    let tags = match tag_database.find_tags(&name) {
        Some(tags) => tags.clone(),
        None => return Err(ExCommandError::Other(format!("Tag not found: {}", name))),
    };
    
    // Get the tag
    let tag = match tags.last() {
        Some(tag) => tag.clone(),
        None => return Err(ExCommandError::Other(format!("No tags found for: {}", name))),
    };
    
    // Set the current tag to the last one
    let last_index = tags.len() - 1;
    tag_database.current_tag = Some((name.clone(), last_index));
    
    // Jump to the tag
    jump_to_tag(editor, &tag)?;
    
    Ok(())
}

/// Handle the :tstack command
fn handle_tstack(_cmd: &ExCommand) -> ExCommandResult<()> {
    // This is just an alias for :tags
    handle_tags(_cmd)
}

/// Handle the :pop command
fn handle_pop(_cmd: &ExCommand) -> ExCommandResult<()> {
    // Get the editor reference
    let editor = unsafe {
        match crate::command::handlers::EDITOR {
            Some(editor_ptr) => &mut *editor_ptr,
            None => return Err(ExCommandError::InvalidCommand("Editor not initialized".to_string())),
        }
    };
    
    // Get the tag database
    let tag_database = unsafe {
        match &mut TAG_DATABASE {
            Some(db) => db,
            None => {
                init_tag_database();
                match &mut TAG_DATABASE {
                    Some(db) => db,
                    None => return Err(ExCommandError::Other("Failed to initialize tag database".to_string())),
                }
            }
        }
    };
    
    // Pop a tag from the stack
    let (name, index) = match tag_database.pop_tag() {
        Some(tag) => tag,
        None => return Err(ExCommandError::Other("Tag stack empty".to_string())),
    };
    
    // Get the tag
    let tags = match tag_database.find_tags(&name) {
        Some(tags) => tags,
        None => return Err(ExCommandError::Other(format!("Tag not found: {}", name))),
    };
    
    // Get the tag
    let tag = match tags.get(index) {
        Some(tag) => tag,
        None => return Err(ExCommandError::Other(format!("Tag index out of range: {}", index))),
    };
    
    // Jump to the tag
    jump_to_tag(editor, tag)?;
    
    Ok(())
}

/// Handle the :settagstack command
fn handle_settagstack(_cmd: &ExCommand) -> ExCommandResult<()> {
    // Get the tag database
    let tag_database = unsafe {
        match &mut TAG_DATABASE {
            Some(db) => db,
            None => {
                init_tag_database();
                match &mut TAG_DATABASE {
                    Some(db) => db,
                    None => return Err(ExCommandError::Other("Failed to initialize tag database".to_string())),
                }
            }
        }
    };
    
    // Clear the tag stack
    tag_database.clear_stack();
    
    println!("Tag stack cleared");
    Ok(())
}

/// Handle the :tagfiles command
fn handle_tagfiles(_cmd: &ExCommand) -> ExCommandResult<()> {
    // Get the tag database
    let tag_database = unsafe {
        match &TAG_DATABASE {
            Some(db) => db,
            None => {
                init_tag_database();
                match &TAG_DATABASE {
                    Some(db) => db,
                    None => return Err(ExCommandError::Other("Failed to initialize tag database".to_string())),
                }
            }
        }
    };
    
    // Display the tag files
    println!("Tag files:");
    
    for (i, file) in tag_database.tag_files.iter().enumerate() {
        println!("{:2}. {}", i + 1, file.display());
    }
    
    Ok(())
}

/// Jump to a tag
fn jump_to_tag(editor: &mut Editor, tag: &TagEntry) -> ExCommandResult<()> {
    // Open the file
    if let Err(err) = editor.open_file(&tag.file) {
        return Err(ExCommandError::Other(format!("Failed to open file: {}", err)));
    }
    
    // If we have a line number, jump to it
    if let Some(line) = tag.line {
        // Convert to 0-based
        let line = line.saturating_sub(1);
        
        // Set the cursor position
        if let Err(err) = editor.get_cursor_manager_mut().set_position(CursorPosition::new(line, 0)) {
            return Err(ExCommandError::Other(format!("Failed to set cursor position: {}", err)));
        }
        
        return Ok(());
    }
    
    // Otherwise, search for the pattern
    let pattern = &tag.pattern;
    
    // Remove the leading / and trailing / from the pattern
    let pattern = if pattern.starts_with('/') && pattern.ends_with('/') {
        &pattern[1..pattern.len() - 1]
    } else {
        pattern
    };
    
    // Search for the pattern
    match editor.search(pattern, true, false) {
        Ok(Some(_)) => Ok(()),
        Ok(None) => Err(ExCommandError::Other(format!("Pattern not found: {}", pattern))),
        Err(err) => Err(ExCommandError::Other(format!("Search error: {}", err))),
    }
}